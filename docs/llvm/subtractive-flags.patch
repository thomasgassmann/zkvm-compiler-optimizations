diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index 1d23ec8ced20..719bd06b8df5 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -59,6 +59,9 @@ static cl::opt<unsigned>
                           cl::desc("The maximum length of a constant string to "
                                    "inline a memchr call."));
 
+static cl::opt<bool> DisableAggressiveInstCombine("disable-pass-aggressive-instcombine", cl::init(false),
+                                                  cl::Hidden, cl::desc("Disable AggressiveInstCombine pass"));
+
 /// Match a pattern for a bitwise funnel/rotate operation that partially guards
 /// against undefined behavior by branching around the funnel-shift/rotation
 /// when the shift amount is 0.
@@ -1273,6 +1276,9 @@ static bool foldUnusualPatterns(Function &F, DominatorTree &DT,
 static bool runImpl(Function &F, AssumptionCache &AC, TargetTransformInfo &TTI,
                     TargetLibraryInfo &TLI, DominatorTree &DT,
                     AliasAnalysis &AA, bool &MadeCFGChange) {
+  if (DisableAggressiveInstCombine)
+    return false;
+
   bool MadeChange = false;
   const DataLayout &DL = F.getDataLayout();
   TruncInstCombine TIC(AC, TLI, DL, DT);
@@ -1283,6 +1289,9 @@ static bool runImpl(Function &F, AssumptionCache &AC, TargetTransformInfo &TTI,
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
+  if (DisableAggressiveInstCombine)
+    return PreservedAnalyses::all();
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
index 1f787c733079..1578ccc21d48 100644
--- a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
+++ b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
@@ -21,6 +21,7 @@
 #include "llvm/Analysis/ProfileSummaryInfo.h"
 #include "llvm/IR/Module.h"
 #include "llvm/InitializePasses.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils/Cloning.h"
 #include "llvm/Transforms/Utils/ModuleUtils.h"
 
@@ -28,6 +29,10 @@ using namespace llvm;
 
 #define DEBUG_TYPE "inline"
 
+static cl::opt<bool> DisablePassAlwaysInline(
+    "disable-pass-always-inline", cl::init(false),
+    cl::desc("Disable the always-inline pass"), cl::Hidden);
+
 namespace {
 
 bool AlwaysInlineImpl(
@@ -35,6 +40,8 @@ bool AlwaysInlineImpl(
     function_ref<AssumptionCache &(Function &)> GetAssumptionCache,
     function_ref<AAResults &(Function &)> GetAAR,
     function_ref<BlockFrequencyInfo &(Function &)> GetBFI) {
+  if (DisablePassAlwaysInline)
+    return false;
   SmallSetVector<CallBase *, 16> Calls;
   bool Changed = false;
   SmallVector<Function *, 16> InlinedComdatFunctions;
@@ -125,6 +132,8 @@ struct AlwaysInlinerLegacyPass : public ModulePass {
 
   /// Main run interface method.  We override here to avoid calling skipSCC().
   bool runOnModule(Module &M) override {
+    if (DisablePassAlwaysInline)
+      return false;
 
     auto &PSI = getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();
     auto GetAAR = [&](Function &F) -> AAResults & {
@@ -164,6 +173,8 @@ Pass *llvm::createAlwaysInlinerLegacyPass(bool InsertLifetime) {
 
 PreservedAnalyses AlwaysInlinerPass::run(Module &M,
                                          ModuleAnalysisManager &MAM) {
+  if (DisablePassAlwaysInline)
+    return PreservedAnalyses::all();
   FunctionAnalysisManager &FAM =
       MAM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   auto GetAssumptionCache = [&](Function &F) -> AssumptionCache & {
diff --git a/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp b/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
index 99ec50aa4775..cd37a430cfd0 100644
--- a/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
+++ b/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
@@ -66,6 +66,7 @@
 #include "llvm/IR/User.h"
 #include "llvm/IR/Value.h"
 #include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/Utils/Local.h"
@@ -83,6 +84,11 @@ using namespace llvm;
 STATISTIC(NumArgumentsPromoted, "Number of pointer arguments promoted");
 STATISTIC(NumArgumentsDead, "Number of dead pointer args eliminated");
 
+static cl::opt<bool> DisablePassArgPromotion("disable-pass-argpromotion",
+                                             cl::init(false),
+                                             cl::desc("Disable argpromotion"),
+                                             cl::Hidden);
+
 namespace {
 
 struct ArgPart {
@@ -861,6 +867,8 @@ PreservedAnalyses ArgumentPromotionPass::run(LazyCallGraph::SCC &C,
                                              CGSCCAnalysisManager &AM,
                                              LazyCallGraph &CG,
                                              CGSCCUpdateResult &UR) {
+  if (DisablePassArgPromotion)
+    return PreservedAnalyses::all();
   bool Changed = false, LocalChange;
 
   // Iterate until we stop promoting from this SCC.
diff --git a/llvm/lib/Transforms/IPO/Attributor.cpp b/llvm/lib/Transforms/IPO/Attributor.cpp
index 910c0aeacc42..52ae1af48b61 100644
--- a/llvm/lib/Transforms/IPO/Attributor.cpp
+++ b/llvm/lib/Transforms/IPO/Attributor.cpp
@@ -66,6 +66,11 @@ using namespace llvm;
 #define DEBUG_TYPE "attributor"
 #define VERBOSE_DEBUG_TYPE DEBUG_TYPE "-verbose"
 
+static cl::opt<bool> DisablePassAttributor("disable-pass-attributor",
+                                             cl::init(false),
+                                             cl::desc("Disable Attributor"),
+                                             cl::Hidden);
+
 DEBUG_COUNTER(ManifestDBGCounter, "attributor-manifest",
               "Determine what attributes are manifested in the IR");
 
@@ -4024,6 +4029,8 @@ void AADepGraph::print() {
 }
 
 PreservedAnalyses AttributorPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisablePassAttributor)
+    return PreservedAnalyses::all();
   FunctionAnalysisManager &FAM =
       AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   AnalysisGetter AG(FAM);
@@ -4047,6 +4054,8 @@ PreservedAnalyses AttributorCGSCCPass::run(LazyCallGraph::SCC &C,
                                            CGSCCAnalysisManager &AM,
                                            LazyCallGraph &CG,
                                            CGSCCUpdateResult &UR) {
+  if (DisablePassAttributor)
+    return PreservedAnalyses::all();
   FunctionAnalysisManager &FAM =
       AM.getResult<FunctionAnalysisManagerCGSCCProxy>(C, CG).getManager();
   AnalysisGetter AG(FAM);
@@ -4076,6 +4085,8 @@ PreservedAnalyses AttributorCGSCCPass::run(LazyCallGraph::SCC &C,
 
 PreservedAnalyses AttributorLightPass::run(Module &M,
                                            ModuleAnalysisManager &AM) {
+  if (DisablePassAttributor)
+    return PreservedAnalyses::all();
   FunctionAnalysisManager &FAM =
       AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   AnalysisGetter AG(FAM, /* CachedOnly */ true);
@@ -4103,6 +4114,8 @@ PreservedAnalyses AttributorLightCGSCCPass::run(LazyCallGraph::SCC &C,
                                                 CGSCCAnalysisManager &AM,
                                                 LazyCallGraph &CG,
                                                 CGSCCUpdateResult &UR) {
+  if (DisablePassAttributor)
+    return PreservedAnalyses::all();
   FunctionAnalysisManager &FAM =
       AM.getResult<FunctionAnalysisManagerCGSCCProxy>(C, CG).getManager();
   AnalysisGetter AG(FAM);
diff --git a/llvm/lib/Transforms/IPO/BlockExtractor.cpp b/llvm/lib/Transforms/IPO/BlockExtractor.cpp
index ec1be35a3316..1a7e504b312c 100644
--- a/llvm/lib/Transforms/IPO/BlockExtractor.cpp
+++ b/llvm/lib/Transforms/IPO/BlockExtractor.cpp
@@ -38,6 +38,9 @@ static cl::opt<bool>
     BlockExtractorEraseFuncs("extract-blocks-erase-funcs",
                              cl::desc("Erase the existing functions"),
                              cl::Hidden);
+
+static cl::opt<bool> DisableExtractBlocks("disable-pass-extract-blocks", cl::init(false), cl::Hidden, cl::desc("Disable ExtractBlocks pass"));
+
 namespace {
 class BlockExtractor {
 public:
@@ -124,6 +127,9 @@ void BlockExtractor::splitLandingPadPreds(Function &F) {
 }
 
 bool BlockExtractor::runOnModule(Module &M) {
+  if (DisableExtractBlocks)
+    return false;
+
   bool Changed = false;
 
   // Get all the functions.
@@ -201,6 +207,8 @@ BlockExtractorPass::BlockExtractorPass(
 
 PreservedAnalyses BlockExtractorPass::run(Module &M,
                                           ModuleAnalysisManager &AM) {
+  if (DisableExtractBlocks)
+    return PreservedAnalyses::all();
   BlockExtractor BE(EraseFunctions);
   BE.init(GroupsOfBlocks);
   return BE.runOnModule(M) ? PreservedAnalyses::none()
diff --git a/llvm/lib/Transforms/IPO/ConstantMerge.cpp b/llvm/lib/Transforms/IPO/ConstantMerge.cpp
index a1face0a6a9c..e22dafca01ab 100644
--- a/llvm/lib/Transforms/IPO/ConstantMerge.cpp
+++ b/llvm/lib/Transforms/IPO/ConstantMerge.cpp
@@ -31,6 +31,7 @@
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Transforms/IPO.h"
+#include "llvm/Support/CommandLine.h"
 #include <algorithm>
 #include <cassert>
 #include <utility>
@@ -39,6 +40,9 @@ using namespace llvm;
 
 #define DEBUG_TYPE "constmerge"
 
+static cl::opt<bool> DisableConstMerge("disable-pass-constmerge", cl::init(false),
+                                       cl::Hidden, cl::desc("Disable ConstantMerge pass"));
+
 STATISTIC(NumIdenticalMerged, "Number of identical global constants merged");
 
 /// Find values that are marked as llvm.used.
@@ -132,6 +136,9 @@ static void replace(Module &M, GlobalVariable *Old, GlobalVariable *New) {
 }
 
 static bool mergeConstants(Module &M) {
+  if (DisableConstMerge)
+    return false;
+
   // Find all the globals that are marked "used".  These cannot be merged.
   SmallPtrSet<const GlobalValue*, 8> UsedGlobals;
   FindUsedValues(M.getGlobalVariable("llvm.used"), UsedGlobals);
@@ -246,6 +253,8 @@ static bool mergeConstants(Module &M) {
 }
 
 PreservedAnalyses ConstantMergePass::run(Module &M, ModuleAnalysisManager &) {
+  if (DisableConstMerge)
+    return PreservedAnalyses::all();
   if (!mergeConstants(M))
     return PreservedAnalyses::all();
   return PreservedAnalyses::none();
diff --git a/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp b/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
index a164c82bdf75..781cbe6092a0 100644
--- a/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
+++ b/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
@@ -42,6 +42,7 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/IPO.h"
@@ -59,6 +60,8 @@ STATISTIC(NumRetValsEliminated, "Number of unused return values removed");
 STATISTIC(NumArgumentsReplacedWithPoison,
           "Number of unread args replaced with poison");
 
+static cl::opt<bool> DisableDeadArgElim("disable-pass-deadargelim", cl::init(false), cl::Hidden, cl::desc("Disable DeadArgumentElimination pass"));
+
 namespace {
 
 /// The dead argument elimination pass.
@@ -75,6 +78,8 @@ public:
   }
 
   bool runOnModule(Module &M) override {
+    if (DisableDeadArgElim)
+      return false;
     if (skipModule(M))
       return false;
     DeadArgumentEliminationPass DAEP(shouldHackArguments());
@@ -1118,6 +1123,8 @@ void DeadArgumentEliminationPass::propagateVirtMustcallLiveness(
 
 PreservedAnalyses DeadArgumentEliminationPass::run(Module &M,
                                                    ModuleAnalysisManager &) {
+  if (DisableDeadArgElim)
+    return PreservedAnalyses::all();
   bool Changed = false;
 
   // First pass: Do a simple check to see if any functions can have their "..."
diff --git a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
index 7b419d0f098b..c76ef6a64379 100644
--- a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
+++ b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
@@ -105,6 +105,8 @@ static cl::opt<bool> DisableThinLTOPropagation(
     "disable-thinlto-funcattrs", cl::init(true), cl::Hidden,
     cl::desc("Don't propagate function-attrs in thinLTO"));
 
+static cl::opt<bool> DisableFunctionAttrs("disable-pass-function-attrs", cl::init(false), cl::Hidden, cl::desc("Disable FunctionAttrs pass"));
+
 namespace {
 
 using SCCNodeSet = SmallSetVector<Function *, 8>;
@@ -1881,6 +1883,8 @@ PreservedAnalyses PostOrderFunctionAttrsPass::run(LazyCallGraph::SCC &C,
                                                   CGSCCAnalysisManager &AM,
                                                   LazyCallGraph &CG,
                                                   CGSCCUpdateResult &) {
+  if (DisableFunctionAttrs)
+    return PreservedAnalyses::all();
   // Skip non-recursive functions if requested.
   // Only infer argument attributes for non-recursive functions, because
   // it can affect optimization behavior in conjunction with noalias.
@@ -2016,6 +2020,9 @@ static bool deduceFunctionAttributeInRPO(Module &M, LazyCallGraph &CG) {
 
 PreservedAnalyses
 ReversePostOrderFunctionAttrsPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisableFunctionAttrs)
+    return PreservedAnalyses::all();
+
   auto &CG = AM.getResult<LazyCallGraphAnalysis>(M);
 
   if (!deduceFunctionAttributeInRPO(M, CG))
diff --git a/llvm/lib/Transforms/IPO/GlobalDCE.cpp b/llvm/lib/Transforms/IPO/GlobalDCE.cpp
index e36d524d7667..8a5f22e7007a 100644
--- a/llvm/lib/Transforms/IPO/GlobalDCE.cpp
+++ b/llvm/lib/Transforms/IPO/GlobalDCE.cpp
@@ -30,6 +30,11 @@ using namespace llvm;
 
 #define DEBUG_TYPE "globaldce"
 
+static cl::opt<bool> DisablePassGlobaldce("disable-pass-globaldce",
+                                          cl::init(false),
+                                          cl::desc("Disable GlobalDCE"),
+                                          cl::Hidden);
+
 static cl::opt<bool>
     ClEnableVFE("enable-vfe", cl::Hidden, cl::init(true),
                 cl::desc("Enable virtual function elimination"));
@@ -247,6 +252,8 @@ void GlobalDCEPass::AddVirtualFunctionDependencies(Module &M) {
 }
 
 PreservedAnalyses GlobalDCEPass::run(Module &M, ModuleAnalysisManager &MAM) {
+  if (DisablePassGlobaldce)
+    return PreservedAnalyses::all();
   bool Changed = false;
 
   // The algorithm first computes the set L of global variables that are
diff --git a/llvm/lib/Transforms/IPO/GlobalOpt.cpp b/llvm/lib/Transforms/IPO/GlobalOpt.cpp
index ab1e41ebf9a9..e06927c3fc64 100644
--- a/llvm/lib/Transforms/IPO/GlobalOpt.cpp
+++ b/llvm/lib/Transforms/IPO/GlobalOpt.cpp
@@ -2558,7 +2558,14 @@ optimizeGlobalsInModule(Module &M, const DataLayout &DL,
   return Changed;
 }
 
+static cl::opt<bool> DisablePassGlobalopt("disable-pass-globalopt",
+                                            cl::init(false),
+                                            cl::desc("Disable GlobalOpt"),
+                                            cl::Hidden);
+
 PreservedAnalyses GlobalOptPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisablePassGlobalopt)
+    return PreservedAnalyses::all();
     auto &DL = M.getDataLayout();
     auto &FAM =
         AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
diff --git a/llvm/lib/Transforms/IPO/GlobalSplit.cpp b/llvm/lib/Transforms/IPO/GlobalSplit.cpp
index fd49b745fd75..7b7941cb680c 100644
--- a/llvm/lib/Transforms/IPO/GlobalSplit.cpp
+++ b/llvm/lib/Transforms/IPO/GlobalSplit.cpp
@@ -31,6 +31,7 @@
 #include "llvm/IR/User.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Transforms/IPO.h"
+#include "llvm/Support/CommandLine.h"
 #include <cstdint>
 #include <vector>
 
@@ -191,7 +192,14 @@ static bool splitGlobals(Module &M) {
   return Changed;
 }
 
+static cl::opt<bool> DisablePassGlobalsplit("disable-pass-globalsplit",
+                                            cl::init(false),
+                                            cl::desc("Disable GlobalSplit"),
+                                            cl::Hidden);
+
 PreservedAnalyses GlobalSplitPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisablePassGlobalsplit)
+    return PreservedAnalyses::all();
   if (!splitGlobals(M))
     return PreservedAnalyses::all();
   return PreservedAnalyses::none();
diff --git a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
index 2ec5da488683..fd2bd22d82f4 100644
--- a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
+++ b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
@@ -67,6 +67,9 @@ using namespace llvm;
 
 static cl::opt<bool> EnableStaticAnalysis("hot-cold-static-analysis",
                                           cl::init(true), cl::Hidden);
+static cl::opt<bool>
+    DisableHotColdSplit("disable-pass-hotcoldsplit", cl::init(false),
+                        cl::Hidden, cl::desc("Disable HotColdSplitting pass"));
 
 static cl::opt<int>
     SplittingThreshold("hotcoldsplit-threshold", cl::init(2), cl::Hidden,
@@ -775,6 +778,8 @@ bool HotColdSplitting::outlineColdRegions(Function &F, bool HasProfileSummary) {
 }
 
 bool HotColdSplitting::run(Module &M) {
+  if (DisableHotColdSplit)
+    return false;
   bool Changed = false;
   bool HasProfileSummary = (M.getProfileSummary(/* IsCS */ false) != nullptr);
   for (Function &F : M) {
@@ -805,6 +810,8 @@ bool HotColdSplitting::run(Module &M) {
 
 PreservedAnalyses
 HotColdSplittingPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisableHotColdSplit)
+    return PreservedAnalyses::all();
   auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
 
   auto LookupAC = [&FAM](Function &F) -> AssumptionCache * {
diff --git a/llvm/lib/Transforms/IPO/Inliner.cpp b/llvm/lib/Transforms/IPO/Inliner.cpp
index 23ee23eb047f..2836fc04aeb5 100644
--- a/llvm/lib/Transforms/IPO/Inliner.cpp
+++ b/llvm/lib/Transforms/IPO/Inliner.cpp
@@ -130,6 +130,9 @@ static cl::opt<ReplayInlinerSettings::Fallback> CGSCCInlineReplayFallback(
         "not in replay, NeverInline: inline no sites not in replay"),
     cl::Hidden);
 
+cl::opt<bool> DisableInliner("disable-pass-inline", cl::init(false), cl::Hidden,
+                             cl::desc("Disable inliner pass"));
+
 static cl::opt<CallSiteFormat::Format> CGSCCInlineReplayFormat(
     "cgscc-inline-replay-format",
     cl::init(CallSiteFormat::Format::LineColumnDiscriminator),
@@ -208,6 +211,9 @@ void makeFunctionBodyUnreachable(Function &F) {
 PreservedAnalyses InlinerPass::run(LazyCallGraph::SCC &InitialC,
                                    CGSCCAnalysisManager &AM, LazyCallGraph &CG,
                                    CGSCCUpdateResult &UR) {
+  if (DisableInliner)
+    return PreservedAnalyses::all();
+
   const auto &MAMProxy =
       AM.getResult<ModuleAnalysisManagerCGSCCProxy>(InitialC, CG);
   bool Changed = false;
@@ -601,6 +607,8 @@ ModuleInlinerWrapperPass::ModuleInlinerWrapperPass(InlineParams Params,
 
 PreservedAnalyses ModuleInlinerWrapperPass::run(Module &M,
                                                 ModuleAnalysisManager &MAM) {
+  if (DisableInliner)
+    return PreservedAnalyses::all();
   auto &IAA = MAM.getResult<InlineAdvisorAnalysis>(M);
   if (!IAA.tryCreate(Params, Mode,
                      {CGSCCInlineReplayFile,
diff --git a/llvm/lib/Transforms/IPO/LoopExtractor.cpp b/llvm/lib/Transforms/IPO/LoopExtractor.cpp
index 9a5876f85ba7..43ba235a2f95 100644
--- a/llvm/lib/Transforms/IPO/LoopExtractor.cpp
+++ b/llvm/lib/Transforms/IPO/LoopExtractor.cpp
@@ -23,6 +23,7 @@
 #include "llvm/IR/PassManager.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/CodeExtractor.h"
@@ -32,6 +33,10 @@ using namespace llvm;
 
 STATISTIC(NumExtracted, "Number of loops extracted");
 
+static cl::opt<bool> DisableLoopExtract("disable-pass-loop-extract",
+                                      cl::init(false), cl::Hidden,
+                                      cl::desc("Disable loop extraction"));
+
 namespace {
 struct LoopExtractorLegacyPass : public ModulePass {
   static char ID; // Pass identification, replacement for typeid
@@ -110,6 +115,8 @@ INITIALIZE_PASS(SingleLoopExtractor, "loop-extract-single",
 Pass *llvm::createLoopExtractorPass() { return new LoopExtractorLegacyPass(); }
 
 bool LoopExtractorLegacyPass::runOnModule(Module &M) {
+  if (DisableLoopExtract)
+    return false;
   if (skipModule(M))
     return false;
 
@@ -131,6 +138,9 @@ bool LoopExtractorLegacyPass::runOnModule(Module &M) {
 }
 
 bool LoopExtractor::runOnModule(Module &M) {
+  if (DisableLoopExtract)
+    return false;
+
   if (M.empty())
     return false;
 
@@ -159,6 +169,9 @@ bool LoopExtractor::runOnModule(Module &M) {
 }
 
 bool LoopExtractor::runOnFunction(Function &F) {
+  if (DisableLoopExtract)
+    return false;
+
   // Do not modify `optnone` functions.
   if (F.hasOptNone())
     return false;
@@ -219,6 +232,9 @@ bool LoopExtractor::runOnFunction(Function &F) {
 
 bool LoopExtractor::extractLoops(Loop::iterator From, Loop::iterator To,
                                  LoopInfo &LI, DominatorTree &DT) {
+  if (DisableLoopExtract)
+    return false;
+
   bool Changed = false;
   SmallVector<Loop *, 8> Loops;
 
@@ -259,6 +275,8 @@ Pass *llvm::createSingleLoopExtractorPass() {
 }
 
 PreservedAnalyses LoopExtractorPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisableLoopExtract)
+    return PreservedAnalyses::all();
   auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   auto LookupDomTree = [&FAM](Function &F) -> DominatorTree & {
     return FAM.getResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/IPO/MergeFunctions.cpp b/llvm/lib/Transforms/IPO/MergeFunctions.cpp
index b50a700e0903..ba2a254945c2 100644
--- a/llvm/lib/Transforms/IPO/MergeFunctions.cpp
+++ b/llvm/lib/Transforms/IPO/MergeFunctions.cpp
@@ -168,6 +168,10 @@ static cl::opt<bool>
                           cl::init(false),
                           cl::desc("Allow mergefunc to create aliases"));
 
+static cl::opt<bool> DisableMergeFunctions("disable-pass-mergefunc",
+                                         cl::init(false), cl::Hidden,
+                                         cl::desc("Disable merging of functions"));
+
 namespace {
 
 class FunctionNode {
@@ -303,6 +307,8 @@ private:
 
 PreservedAnalyses MergeFunctionsPass::run(Module &M,
                                           ModuleAnalysisManager &AM) {
+  if (DisableMergeFunctions)
+    return PreservedAnalyses::all();
   MergeFunctions MF;
   if (!MF.runOnModule(M))
     return PreservedAnalyses::all();
@@ -411,6 +417,9 @@ static bool isEligibleForMerging(Function &F) {
 }
 
 bool MergeFunctions::runOnModule(Module &M) {
+  if (DisableMergeFunctions)
+    return false;
+
   bool Changed = false;
 
   SmallVector<GlobalValue *, 4> UsedV;
diff --git a/llvm/lib/Transforms/IPO/ModuleInliner.cpp b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
index 5e91ab80d750..252f1af87e79 100644
--- a/llvm/lib/Transforms/IPO/ModuleInliner.cpp
+++ b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
@@ -48,6 +48,8 @@ using namespace llvm;
 STATISTIC(NumInlined, "Number of functions inlined");
 STATISTIC(NumDeleted, "Number of functions deleted because all callers found");
 
+extern cl::opt<bool> DisableInliner;
+
 /// Return true if the specified inline history ID
 /// indicates an inline history that includes the specified function.
 static bool inlineHistoryIncludes(
@@ -102,6 +104,9 @@ static bool isKnownLibFunction(Function &F, TargetLibraryInfo &TLI) {
 
 PreservedAnalyses ModuleInlinerPass::run(Module &M,
                                          ModuleAnalysisManager &MAM) {
+  if (DisableInliner)
+    return PreservedAnalyses::all();
+
   LLVM_DEBUG(dbgs() << "---- Module Inliner is Running ---- \n");
 
   auto &IAA = MAM.getResult<InlineAdvisorAnalysis>(M);
diff --git a/llvm/lib/Transforms/IPO/SCCP.cpp b/llvm/lib/Transforms/IPO/SCCP.cpp
index 94ae511b2e4a..f972b9639763 100644
--- a/llvm/lib/Transforms/IPO/SCCP.cpp
+++ b/llvm/lib/Transforms/IPO/SCCP.cpp
@@ -47,6 +47,10 @@ static cl::opt<unsigned> FuncSpecMaxIters(
     "funcspec-max-iters", cl::init(10), cl::Hidden, cl::desc(
     "The maximum number of iterations function specialization is run"));
 
+
+static cl::opt<bool> DisablePassIpsccp("disable-pass-ipsccp", cl::init(false),
+                                       cl::desc("Disable IPSCCP"), cl::Hidden);
+
 static void findReturnsToZap(Function &F,
                              SmallVector<ReturnInst *, 8> &ReturnsToZap,
                              SCCPSolver &Solver) {
@@ -381,6 +385,8 @@ static bool runIPSCCP(
 }
 
 PreservedAnalyses IPSCCPPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisablePassIpsccp)
+    return PreservedAnalyses::all();
   const DataLayout &DL = M.getDataLayout();
   auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   auto GetTLI = [&FAM](Function &F) -> const TargetLibraryInfo & {
diff --git a/llvm/lib/Transforms/IPO/StripSymbols.cpp b/llvm/lib/Transforms/IPO/StripSymbols.cpp
index 28d7d4ba6b01..c2fd91c75bf2 100644
--- a/llvm/lib/Transforms/IPO/StripSymbols.cpp
+++ b/llvm/lib/Transforms/IPO/StripSymbols.cpp
@@ -42,6 +42,10 @@ static cl::opt<bool>
                          cl::desc("Removes debug compile units which reference "
                                   "to non-existing global constants"));
 
+static cl::opt<bool> DisableStripSymbols("disable-pass-strip", cl::init(false),
+                                         cl::Hidden,
+                                         cl::desc("Disable stripping of symbols"));
+
 /// OnlyUsedBy - Return true if V is only used by Usr.
 static bool OnlyUsedBy(Value *V, Value *Usr) {
   for (User *U : V->users())
@@ -268,6 +272,8 @@ static bool stripDeadDebugInfoImpl(Module &M) {
 }
 
 PreservedAnalyses StripSymbolsPass::run(Module &M, ModuleAnalysisManager &AM) {
+  if (DisableStripSymbols)
+    return PreservedAnalyses::all();
   StripDebugInfo(M);
   StripSymbolNames(M, false);
   PreservedAnalyses PA;
@@ -277,6 +283,8 @@ PreservedAnalyses StripSymbolsPass::run(Module &M, ModuleAnalysisManager &AM) {
 
 PreservedAnalyses StripNonDebugSymbolsPass::run(Module &M,
                                                 ModuleAnalysisManager &AM) {
+  if (DisableStripSymbols)
+    return PreservedAnalyses::all();
   StripSymbolNames(M, true);
   PreservedAnalyses PA;
   PA.preserveSet<CFGAnalyses>();
@@ -285,6 +293,8 @@ PreservedAnalyses StripNonDebugSymbolsPass::run(Module &M,
 
 PreservedAnalyses StripDebugDeclarePass::run(Module &M,
                                              ModuleAnalysisManager &AM) {
+  if (DisableStripSymbols)
+    return PreservedAnalyses::all();
   stripDebugDeclareImpl(M);
   PreservedAnalyses PA;
   PA.preserveSet<CFGAnalyses>();
@@ -293,6 +303,8 @@ PreservedAnalyses StripDebugDeclarePass::run(Module &M,
 
 PreservedAnalyses StripDeadDebugInfoPass::run(Module &M,
                                               ModuleAnalysisManager &AM) {
+  if (DisableStripSymbols)
+    return PreservedAnalyses::all();
   stripDeadDebugInfoImpl(M);
   PreservedAnalyses PA;
   PA.preserveSet<CFGAnalyses>();
diff --git a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
index 19bc841b1052..7b7805f1d8cf 100644
--- a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
+++ b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
@@ -182,6 +182,10 @@ static cl::opt<WPDCheckMode> DevirtCheckMode(
                clEnumValN(WPDCheckMode::Fallback, "fallback",
                           "Fallback to indirect when incorrect")));
 
+static cl::opt<bool> DisableWholeProgramDevirt(
+    "disable-pass-wholeprogramdevirt", cl::init(false), cl::Hidden,
+    cl::desc("Disable whole program devirtualization"));
+
 namespace {
 struct PatternList {
   std::vector<GlobPattern> Patterns;
@@ -752,6 +756,8 @@ struct DevirtIndex {
 
 PreservedAnalyses WholeProgramDevirtPass::run(Module &M,
                                               ModuleAnalysisManager &AM) {
+  if (DisableWholeProgramDevirt)
+    return PreservedAnalyses::all();
   auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
   auto AARGetter = [&](Function &F) -> AAResults & {
     return FAM.getResult<AAManager>(F);
@@ -1160,6 +1166,8 @@ bool DevirtIndex::tryFindVirtualCallTargets(
 
 void DevirtModule::applySingleImplDevirt(VTableSlotInfo &SlotInfo,
                                          Constant *TheFn, bool &IsExported) {
+  if (DisableWholeProgramDevirt)
+    return;
   // Don't devirtualize function if we're told to skip it
   // in -wholeprogramdevirt-skip.
   if (FunctionsToSkip.match(TheFn->stripPointerCasts()->getName()))
@@ -2236,6 +2244,9 @@ bool DevirtModule::mustBeUnreachableFunction(
 }
 
 bool DevirtModule::run() {
+  if (DisableWholeProgramDevirt)
+    return false;
+
   // If only some of the modules were split, we cannot correctly perform
   // this transformation. We already checked for the presense of type tests
   // with partially split modules during the thin link, and would have emitted
@@ -2438,6 +2449,9 @@ bool DevirtModule::run() {
 }
 
 void DevirtIndex::run() {
+  if (DisableWholeProgramDevirt)
+    return;
+
   if (ExportSummary.typeIdCompatibleVtableMap().empty())
     return;
 
diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index 0d8e7e92c5c8..6adc27bc2281 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -142,6 +142,9 @@ static cl::opt<unsigned>
 MaxArraySize("instcombine-maxarray-size", cl::init(1024),
              cl::desc("Maximum array size considered when doing a combine"));
 
+static cl::opt<bool> DisableInstCombine("disable-pass-instcombine", cl::init(false),
+                                        cl::Hidden, cl::desc("Disable InstCombine pass"));
+
 // FIXME: Remove this flag when it is no longer necessary to convert
 // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false
 // increases variable availability at the cost of accuracy. Variables that
@@ -5001,6 +5004,9 @@ void InstCombinerImpl::tryToSinkInstructionDbgVariableRecords(
 }
 
 bool InstCombinerImpl::run() {
+  if (DisableInstCombine)
+    return false;
+
   while (!Worklist.isEmpty()) {
     // Walk deferred instructions in reverse order, and push them to the
     // worklist, which means they'll end up popped from the worklist in-order.
@@ -5461,6 +5467,9 @@ void InstCombinePass::printPipeline(
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisableInstCombine)
+    return PreservedAnalyses::all();
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
@@ -5509,6 +5518,9 @@ void InstructionCombiningPass::getAnalysisUsage(AnalysisUsage &AU) const {
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
+  if (DisableInstCombine)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -5538,7 +5550,6 @@ bool InstructionCombiningPass::runOnFunction(Function &F) {
                                          BFI, BPI, PSI, LI,
                                          InstCombineOptions());
 }
-
 char InstructionCombiningPass::ID = 0;
 
 InstructionCombiningPass::InstructionCombiningPass() : FunctionPass(ID) {
diff --git a/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp b/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
index 618b6fe1aea4..17837d8c9d8e 100644
--- a/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
+++ b/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
@@ -40,6 +40,8 @@ static cl::opt<bool> SingleTrapBB("bounds-checking-single-trap",
 static cl::opt<bool> DebugTrapBB("bounds-checking-unique-traps",
                                  cl::desc("Always use one trap per check"));
 
+static cl::opt<bool> DisableBoundsChecking("disable-pass-bounds-checking", cl::init(false), cl::Hidden, cl::desc("Disable BoundsChecking pass"));
+
 STATISTIC(ChecksAdded, "Bounds checks added");
 STATISTIC(ChecksSkipped, "Bounds checks skipped");
 STATISTIC(ChecksUnable, "Bounds checks unable to add");
@@ -223,6 +225,8 @@ static bool addBoundsChecking(Function &F, TargetLibraryInfo &TLI,
 }
 
 PreservedAnalyses BoundsCheckingPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableBoundsChecking)
+    return PreservedAnalyses::all();
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &SE = AM.getResult<ScalarEvolutionAnalysis>(F);
 
diff --git a/llvm/lib/Transforms/Scalar/ADCE.cpp b/llvm/lib/Transforms/Scalar/ADCE.cpp
index 5f0a9b22c3ee..4f7282dff7f7 100644
--- a/llvm/lib/Transforms/Scalar/ADCE.cpp
+++ b/llvm/lib/Transforms/Scalar/ADCE.cpp
@@ -70,6 +70,9 @@ static cl::opt<bool> RemoveControlFlowFlag("adce-remove-control-flow",
 static cl::opt<bool> RemoveLoops("adce-remove-loops", cl::init(false),
                                  cl::Hidden);
 
+static cl::opt<bool> DisableADCE("disable-pass-adce", cl::init(false),
+                                 cl::Hidden, cl::desc("Disable ADCE pass"));
+
 namespace {
 
 /// Information about Instructions
@@ -720,6 +723,9 @@ void AggressiveDeadCodeElimination::makeUnconditional(BasicBlock *BB,
 //
 //===----------------------------------------------------------------------===//
 PreservedAnalyses ADCEPass::run(Function &F, FunctionAnalysisManager &FAM) {
+  if (DisableADCE)
+    return PreservedAnalyses::all();
+
   // ADCE does not need DominatorTree, but require DominatorTree here
   // to update analysis if it is already available.
   auto *DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/BDCE.cpp b/llvm/lib/Transforms/Scalar/BDCE.cpp
index d96dbca30fdb..9ab7c7709e5f 100644
--- a/llvm/lib/Transforms/Scalar/BDCE.cpp
+++ b/llvm/lib/Transforms/Scalar/BDCE.cpp
@@ -33,6 +33,9 @@ using namespace PatternMatch;
 
 #define DEBUG_TYPE "bdce"
 
+static cl::opt<bool> DisablePassBdce("disable-pass-bdce", cl::init(false),
+                                     cl::desc("Disable BDCE"), cl::Hidden);
+
 STATISTIC(NumRemoved, "Number of instructions removed (unused)");
 STATISTIC(NumSimplified, "Number of instructions trivialized (dead bits)");
 STATISTIC(NumSExt2ZExt,
@@ -200,6 +203,9 @@ static bool bitTrackingDCE(Function &F, DemandedBits &DB) {
 }
 
 PreservedAnalyses BDCEPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisablePassBdce)
+    return PreservedAnalyses::all();
+
   auto &DB = AM.getResult<DemandedBitsAnalysis>(F);
   if (!bitTrackingDCE(F, DB))
     return PreservedAnalyses::all();
diff --git a/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp b/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
index 4a6dedc93d30..9e1444397ab5 100644
--- a/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
+++ b/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp
@@ -94,6 +94,8 @@ MinNumOfDependentToRebase("consthoist-min-num-to-rebase",
              "than this number."),
     cl::init(0), cl::Hidden);
 
+static cl::opt<bool> DisableConstantHoisting("disable-pass-consthoist", cl::init(false), cl::Hidden, cl::desc("Disable ConstantHoisting pass"));
+
 namespace {
 
 /// The constant hoisting pass.
@@ -141,6 +143,8 @@ FunctionPass *llvm::createConstantHoistingPass() {
 
 /// Perform the constant hoisting optimization for the given function.
 bool ConstantHoistingLegacyPass::runOnFunction(Function &Fn) {
+  if (DisableConstantHoisting)
+    return false;
   if (skipFunction(Fn))
     return false;
 
@@ -946,6 +950,8 @@ void ConstantHoistingPass::deleteDeadCastInst() const {
 bool ConstantHoistingPass::runImpl(Function &Fn, TargetTransformInfo &TTI,
                                    DominatorTree &DT, BlockFrequencyInfo *BFI,
                                    BasicBlock &Entry, ProfileSummaryInfo *PSI) {
+  if (DisableConstantHoisting)
+    return false;
   this->TTI = &TTI;
   this->DT = &DT;
   this->BFI = BFI;
@@ -988,6 +994,8 @@ bool ConstantHoistingPass::runImpl(Function &Fn, TargetTransformInfo &TTI,
 
 PreservedAnalyses ConstantHoistingPass::run(Function &F,
                                             FunctionAnalysisManager &AM) {
+  if (DisableConstantHoisting)
+    return PreservedAnalyses::all();
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   auto BFI = ConstHoistWithBlockFrequency
diff --git a/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp b/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
index 95de8eceb6be..040b0388ffb0 100644
--- a/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
+++ b/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp
@@ -1204,8 +1204,16 @@ static bool processAnd(BinaryOperator *BinOp, LazyValueInfo *LVI) {
   return true;
 }
 
+static cl::opt<bool> DisablePassCorrelatedPropagation(
+    "disable-pass-correlated-propagation", cl::init(false),
+    cl::desc("Disable CorrelatedValuePropagation"), cl::Hidden);
+
+
 static bool runImpl(Function &F, LazyValueInfo *LVI, DominatorTree *DT,
                     const SimplifyQuery &SQ) {
+  if (DisablePassCorrelatedPropagation)
+    return false;
+
   bool FnChanged = false;
   // Visiting in a pre-order depth-first traversal causes us to simplify early
   // blocks before querying later blocks (which require us to analyze early
@@ -1294,6 +1302,8 @@ static bool runImpl(Function &F, LazyValueInfo *LVI, DominatorTree *DT,
 
 PreservedAnalyses
 CorrelatedValuePropagationPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisablePassCorrelatedPropagation)
+    return PreservedAnalyses::all();
   LazyValueInfo *LVI = &AM.getResult<LazyValueAnalysis>(F);
   DominatorTree *DT = &AM.getResult<DominatorTreeAnalysis>(F);
 
diff --git a/llvm/lib/Transforms/Scalar/DCE.cpp b/llvm/lib/Transforms/Scalar/DCE.cpp
index 2ad46130dc94..28338597a714 100644
--- a/llvm/lib/Transforms/Scalar/DCE.cpp
+++ b/llvm/lib/Transforms/Scalar/DCE.cpp
@@ -23,6 +23,7 @@
 #include "llvm/IR/Instruction.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/DebugCounter.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/AssumeBundleBuilder.h"
@@ -33,11 +34,16 @@ using namespace llvm;
 #define DEBUG_TYPE "dce"
 
 STATISTIC(DCEEliminated, "Number of insts removed");
+
+static cl::opt<bool> DisableDCE("disable-pass-dce", cl::init(false), cl::Hidden, cl::desc("Disable DCE pass"));
+
 DEBUG_COUNTER(DCECounter, "dce-transform",
               "Controls which instructions are eliminated");
 
 PreservedAnalyses
 RedundantDbgInstEliminationPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableDCE)
+    return PreservedAnalyses::all();
   bool Changed = false;
   for (auto &BB : F)
     Changed |= RemoveRedundantDbgInstrs(&BB);
@@ -87,6 +93,8 @@ static bool DCEInstruction(Instruction *I,
 }
 
 static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
+  if (DisableDCE)
+    return false;
   bool MadeChange = false;
   SmallSetVector<Instruction *, 16> WorkList;
   // Iterate over the original function, only adding insts to the worklist
@@ -107,6 +115,8 @@ static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
 }
 
 PreservedAnalyses DCEPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableDCE)
+    return PreservedAnalyses::all();
   if (!eliminateDeadCode(F, &AM.getResult<TargetLibraryAnalysis>(F)))
     return PreservedAnalyses::all();
 
@@ -123,6 +133,8 @@ struct DCELegacyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableDCE)
+      return false;
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp b/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
index 931606c6f8fe..3d801be00f71 100644
--- a/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
+++ b/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
@@ -164,6 +164,9 @@ static cl::opt<bool>
     OptimizeMemorySSA("dse-optimize-memoryssa", cl::init(true), cl::Hidden,
                       cl::desc("Allow DSE to optimize memory accesses."));
 
+static cl::opt<bool> DisableDSE("disable-pass-dse", cl::init(false),
+                                cl::Hidden, cl::desc("Disable DSE pass"));
+
 //===----------------------------------------------------------------------===//
 // Helper functions
 //===----------------------------------------------------------------------===//
@@ -2138,6 +2141,9 @@ static bool eliminateDeadStores(Function &F, AliasAnalysis &AA, MemorySSA &MSSA,
                                 DominatorTree &DT, PostDominatorTree &PDT,
                                 const TargetLibraryInfo &TLI,
                                 const LoopInfo &LI) {
+  if (DisableDSE)
+    return false;
+
   bool MadeChange = false;
 
   DSEState State(F, AA, MSSA, DT, PDT, TLI, LI);
@@ -2330,6 +2336,9 @@ static bool eliminateDeadStores(Function &F, AliasAnalysis &AA, MemorySSA &MSSA,
 // DSE Pass
 //===----------------------------------------------------------------------===//
 PreservedAnalyses DSEPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableDSE)
+    return PreservedAnalyses::all();
+
   AliasAnalysis &AA = AM.getResult<AAManager>(F);
   const TargetLibraryInfo &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/EarlyCSE.cpp b/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
index cf11f5bc885a..5a959cddd580 100644
--- a/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
+++ b/llvm/lib/Transforms/Scalar/EarlyCSE.cpp
@@ -83,6 +83,8 @@ static cl::opt<bool> EarlyCSEDebugHash(
     cl::desc("Perform extra assertion checking to verify that SimpleValue's hash "
              "function is well-behaved w.r.t. its isEqual predicate"));
 
+static cl::opt<bool> DisableEarlyCSE("disable-pass-early-cse", cl::init(false), cl::Hidden, cl::desc("Disable EarlyCSE pass"));
+
 //===----------------------------------------------------------------------===//
 // SimpleValue
 //===----------------------------------------------------------------------===//
@@ -1774,6 +1776,9 @@ bool EarlyCSE::processNode(DomTreeNode *Node) {
 }
 
 bool EarlyCSE::run() {
+  if (DisableEarlyCSE)
+    return false;
+
   // Note, deque is being used here because there is significant performance
   // gains over vector when the container becomes very large due to the
   // specific access patterns. For more information see the mailing list
@@ -1826,6 +1831,8 @@ bool EarlyCSE::run() {
 
 PreservedAnalyses EarlyCSEPass::run(Function &F,
                                     FunctionAnalysisManager &AM) {
+  if (DisableEarlyCSE)
+    return PreservedAnalyses::all();
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
@@ -1877,6 +1884,8 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableEarlyCSE)
+      return false;
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/GVN.cpp b/llvm/lib/Transforms/Scalar/GVN.cpp
index db39d8621d07..2261c56d0a8f 100644
--- a/llvm/lib/Transforms/Scalar/GVN.cpp
+++ b/llvm/lib/Transforms/Scalar/GVN.cpp
@@ -135,6 +135,9 @@ static cl::opt<uint32_t> MaxNumInsnsPerBlock(
     cl::desc("Max number of instructions to scan in each basic block in GVN "
              "(default = 100)"));
 
+static cl::opt<bool> DisableGVN("disable-pass-gvn", cl::init(false), cl::Hidden,
+                            cl::desc("Disable GVN pass"));
+
 struct llvm::GVNPass::Expression {
   uint32_t opcode;
   bool commutative = false;
@@ -2613,6 +2616,9 @@ bool GVNPass::propagateEquality(Value *LHS, Value *RHS,
 /// When calculating availability, handle an instruction
 /// by inserting it into the appropriate sets
 bool GVNPass::processInstruction(Instruction *I) {
+  if (DisableGVN)
+    return false;
+
   // Ignore dbg info intrinsics.
   if (isa<DbgInfoIntrinsic>(I))
     return false;
@@ -2759,6 +2765,8 @@ bool GVNPass::runImpl(Function &F, AssumptionCache &RunAC, DominatorTree &RunDT,
                       const TargetLibraryInfo &RunTLI, AAResults &RunAA,
                       MemoryDependenceResults *RunMD, LoopInfo &LI,
                       OptimizationRemarkEmitter *RunORE, MemorySSA *MSSA) {
+  if (DisableGVN)
+    return false;
   AC = &RunAC;
   DT = &RunDT;
   VN.setDomTree(DT);
@@ -2826,6 +2834,9 @@ bool GVNPass::runImpl(Function &F, AssumptionCache &RunAC, DominatorTree &RunDT,
 }
 
 bool GVNPass::processBlock(BasicBlock *BB) {
+  if (DisableGVN)
+    return false;
+
   // FIXME: Kill off InstrsToErase by doing erasing eagerly in a helper function
   // (and incrementing BI before processing an instruction).
   assert(InstrsToErase.empty() &&
@@ -3343,6 +3354,9 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableGVN)
+      return false;
+
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/GVNHoist.cpp b/llvm/lib/Transforms/Scalar/GVNHoist.cpp
index b5333c532280..4f3ea0b98402 100644
--- a/llvm/lib/Transforms/Scalar/GVNHoist.cpp
+++ b/llvm/lib/Transforms/Scalar/GVNHoist.cpp
@@ -108,6 +108,8 @@ static cl::opt<int>
                    cl::desc("Maximum length of dependent chains to hoist "
                             "(default = 10, unlimited = -1)"));
 
+static cl::opt<bool> DisableGVNHoist("disable-pass-gvn-hoist", cl::init(false), cl::Hidden, cl::desc("Disable GVNHoist pass"));
+
 namespace llvm {
 
 using BBSideEffectsSet = DenseMap<const BasicBlock *, bool>;
@@ -505,6 +507,8 @@ private:
 };
 
 bool GVNHoist::run(Function &F) {
+  if (DisableGVNHoist)
+    return false;
   NumFuncArgs = F.arg_size();
   VN.setDomTree(DT);
   VN.setAliasAnalysis(AA);
@@ -1202,6 +1206,8 @@ std::pair<unsigned, unsigned> GVNHoist::hoistExpressions(Function &F) {
 } // end namespace llvm
 
 PreservedAnalyses GVNHoistPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableGVNHoist)
+    return PreservedAnalyses::all();
   DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);
   PostDominatorTree &PDT = AM.getResult<PostDominatorTreeAnalysis>(F);
   AliasAnalysis &AA = AM.getResult<AAManager>(F);
diff --git a/llvm/lib/Transforms/Scalar/GVNSink.cpp b/llvm/lib/Transforms/Scalar/GVNSink.cpp
index 3dfa2dd9df27..5de8cb90d4aa 100644
--- a/llvm/lib/Transforms/Scalar/GVNSink.cpp
+++ b/llvm/lib/Transforms/Scalar/GVNSink.cpp
@@ -58,6 +58,7 @@
 #include "llvm/Support/ArrayRecycler.h"
 #include "llvm/Support/AtomicOrdering.h"
 #include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
@@ -78,6 +79,8 @@ using namespace llvm;
 
 STATISTIC(NumRemoved, "Number of instructions removed");
 
+static cl::opt<bool> DisableGVNSink("disable-pass-gvn-sink", cl::init(false), cl::Hidden, cl::desc("Disable GVNSink pass"));
+
 namespace llvm {
 namespace GVNExpression {
 
@@ -938,6 +941,8 @@ void GVNSink::sinkLastInstruction(ArrayRef<BasicBlock *> Blocks,
 } // end anonymous namespace
 
 PreservedAnalyses GVNSinkPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableGVNSink)
+    return PreservedAnalyses::all();
   GVNSink G;
   if (!G.run(F))
     return PreservedAnalyses::all();
diff --git a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
index 5e2131b0b180..6149f0c94335 100644
--- a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
+++ b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
@@ -124,6 +124,10 @@ static cl::opt<bool>
 AllowIVWidening("indvars-widen-indvars", cl::Hidden, cl::init(true),
                 cl::desc("Allow widening of indvars to eliminate s/zext"));
 
+static cl::opt<bool>
+    DisableIndVarSimplify("disable-pass-indvars", cl::init(false), cl::Hidden,
+                          cl::desc("Disable IndVarSimplify pass"));
+
 namespace {
 
 class IndVarSimplify {
@@ -1896,6 +1900,9 @@ bool IndVarSimplify::predicateLoopExits(Loop *L, SCEVExpander &Rewriter) {
 //===----------------------------------------------------------------------===//
 
 bool IndVarSimplify::run(Loop *L) {
+  if (DisableIndVarSimplify)
+    return false;
+
   // We need (and expect!) the incoming loop to be in LCSSA.
   assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&
          "LCSSA required to run indvars!");
@@ -2061,6 +2068,9 @@ bool IndVarSimplify::run(Loop *L) {
 PreservedAnalyses IndVarSimplifyPass::run(Loop &L, LoopAnalysisManager &AM,
                                           LoopStandardAnalysisResults &AR,
                                           LPMUpdater &) {
+  if (DisableIndVarSimplify)
+    return PreservedAnalyses::all();
+
   Function *F = L.getHeader()->getParent();
   const DataLayout &DL = F->getDataLayout();
 
diff --git a/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp b/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
index 104e8ceb7967..9c55e82e02a8 100644
--- a/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
+++ b/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp
@@ -130,6 +130,8 @@ static cl::opt<bool>
 
 #define DEBUG_TYPE "irce"
 
+static cl::opt<bool> DisableIRCE("disable-pass-irce", cl::init(false), cl::Hidden, cl::desc("Disable InductiveRangeCheckElimination pass"));
+
 namespace {
 
 /// An inductive range check is conditional branch in a loop with
@@ -883,6 +885,8 @@ IntersectUnsignedRange(ScalarEvolution &SE,
 }
 
 PreservedAnalyses IRCEPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableIRCE)
+    return PreservedAnalyses::all();
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   LoopInfo &LI = AM.getResult<LoopAnalysis>(F);
   // There are no loops in the function. Return before computing other expensive
@@ -973,6 +977,8 @@ InductiveRangeCheckElimination::isProfitableToTransform(const Loop &L,
 
 bool InductiveRangeCheckElimination::run(
     Loop *L, function_ref<void(Loop *, bool)> LPMAddNewLoop) {
+  if (DisableIRCE)
+    return false;
   if (L->getBlocks().size() >= LoopSizeCutoff) {
     LLVM_DEBUG(dbgs() << "irce: giving up constraining loop, too large\n");
     return false;
diff --git a/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp b/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
index 326849a4eb39..3b480b226df5 100644
--- a/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
+++ b/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp
@@ -25,7 +25,11 @@ using namespace llvm;
 
 STATISTIC(NumSimplified, "Number of redundant instructions removed");
 
+static cl::opt<bool> DisableInstSimplify("disable-pass-instsimplify", cl::init(false), cl::Hidden, cl::desc("Disable InstSimplify pass"));
+
 static bool runImpl(Function &F, const SimplifyQuery &SQ) {
+  if (DisableInstSimplify)
+    return false;
   SmallPtrSet<const Instruction *, 8> S1, S2, *ToSimplify = &S1, *Next = &S2;
   bool Changed = false;
 
@@ -90,6 +94,8 @@ struct InstSimplifyLegacyPass : public FunctionPass {
 
   /// Remove instructions that simplify.
   bool runOnFunction(Function &F) override {
+    if (DisableInstSimplify)
+      return false;
     if (skipFunction(F))
       return false;
 
@@ -122,6 +128,8 @@ FunctionPass *llvm::createInstSimplifyLegacyPass() {
 
 PreservedAnalyses InstSimplifyPass::run(Function &F,
                                         FunctionAnalysisManager &AM) {
+  if (DisableInstSimplify)
+    return PreservedAnalyses::all();
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/JumpThreading.cpp b/llvm/lib/Transforms/Scalar/JumpThreading.cpp
index 7a0b661a0779..e071ecbbd9b7 100644
--- a/llvm/lib/Transforms/Scalar/JumpThreading.cpp
+++ b/llvm/lib/Transforms/Scalar/JumpThreading.cpp
@@ -107,6 +107,9 @@ static cl::opt<bool> ThreadAcrossLoopHeaders(
     cl::desc("Allow JumpThreading to thread across loop headers, for testing"),
     cl::init(false), cl::Hidden);
 
+static cl::opt<bool> DisableJumpThreading("disable-pass-jump-threading", cl::init(false),
+                                          cl::Hidden, cl::desc("Disable JumpThreading pass"));
+
 JumpThreadingPass::JumpThreadingPass(int T) {
   DefaultBBDupThreshold = (T == -1) ? BBDuplicateThreshold : unsigned(T);
 }
@@ -237,6 +240,9 @@ static void updatePredecessorProfileMetadata(PHINode *PN, BasicBlock *BB) {
 
 PreservedAnalyses JumpThreadingPass::run(Function &F,
                                          FunctionAnalysisManager &AM) {
+  if (DisableJumpThreading)
+    return PreservedAnalyses::all();
+
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   // Jump Threading has no sense for the targets with divergent CF
   if (TTI.hasBranchDivergence(&F))
@@ -947,6 +953,9 @@ static bool hasAddressTakenAndUsed(BasicBlock *BB) {
 /// processBlock - If there are any predecessors whose control can be threaded
 /// through to a successor, transform them now.
 bool JumpThreadingPass::processBlock(BasicBlock *BB) {
+  if (DisableJumpThreading)
+    return false;
+
   // If the block is trivially dead, just return and let the caller nuke it.
   // This simplifies other transformations.
   if (DTU->isBBPendingDeletion(BB) ||
@@ -2748,7 +2757,7 @@ bool JumpThreadingPass::duplicateCondBranchOnPHIIntoPred(
 // Pred is a predecessor of BB with an unconditional branch to BB. SI is
 // a Select instruction in Pred. BB has other predecessors and SI is used in
 // a PHI node in BB. SI has no other use.
-// A new basic block, NewBB, is created and SI is converted to compare and 
+// A new basic block, NewBB, is created and SI is converted to compare and
 // conditional branch. SI is erased from parent.
 void JumpThreadingPass::unfoldSelectInstr(BasicBlock *Pred, BasicBlock *BB,
                                           SelectInst *SI, PHINode *SIUse,
diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index ca03eff7a4e2..4212b703fab3 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -119,6 +119,9 @@ static cl::opt<bool>
     DisablePromotion("disable-licm-promotion", cl::Hidden, cl::init(false),
                      cl::desc("Disable memory promotion in LICM pass"));
 
+static cl::opt<bool> DisableLICM("disable-pass-licm", cl::init(false),
+                                 cl::Hidden, cl::desc("Disable LICM pass"));
+
 static cl::opt<bool> ControlFlowHoisting(
     "licm-control-flow-hoisting", cl::Hidden, cl::init(false),
     cl::desc("Enable control flow (and PHI) hoisting in LICM"));
@@ -245,6 +248,8 @@ struct LegacyLICMPass : public LoopPass {
   }
 
   bool runOnLoop(Loop *L, LPPassManager &LPM) override {
+    if (DisableLICM)
+      return false;
     if (skipLoop(L))
       return false;
 
@@ -293,6 +298,8 @@ private:
 
 PreservedAnalyses LICMPass::run(Loop &L, LoopAnalysisManager &AM,
                                 LoopStandardAnalysisResults &AR, LPMUpdater &) {
+  if (DisableLICM)
+    return PreservedAnalyses::all();
   if (!AR.MSSA)
     report_fatal_error("LICM requires MemorySSA (loop-mssa)",
                        /*GenCrashDiag*/false);
@@ -327,6 +334,8 @@ void LICMPass::printPipeline(
 PreservedAnalyses LNICMPass::run(LoopNest &LN, LoopAnalysisManager &AM,
                                  LoopStandardAnalysisResults &AR,
                                  LPMUpdater &) {
+  if (DisableLICM)
+    return PreservedAnalyses::all();
   if (!AR.MSSA)
     report_fatal_error("LNICM requires MemorySSA (loop-mssa)",
                        /*GenCrashDiag*/false);
@@ -412,6 +421,8 @@ bool LoopInvariantCodeMotion::runOnLoop(Loop *L, AAResults *AA, LoopInfo *LI,
                                         ScalarEvolution *SE, MemorySSA *MSSA,
                                         OptimizationRemarkEmitter *ORE,
                                         bool LoopNestMode) {
+  if (DisableLICM)
+    return false;
   bool Changed = false;
 
   assert(L->isLCSSAForm(*DT) && "Loop is not in LCSSA form.");
diff --git a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
index d85166e518f1..c8d767ca1557 100644
--- a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
@@ -54,6 +54,10 @@ static cl::opt<unsigned> MaxPrefetchIterationsAhead(
     "max-prefetch-iters-ahead",
     cl::desc("Max number of iterations to prefetch ahead"), cl::Hidden);
 
+static cl::opt<bool> DisableLoopDataPrefetch(
+    "disable-pass-loop-data-prefetch", cl::init(false), cl::Hidden,
+    cl::desc("Disable loop data prefetching"));
+
 STATISTIC(NumPrefetches, "Number of prefetches inserted");
 
 namespace {
@@ -171,6 +175,8 @@ bool LoopDataPrefetch::isStrideLargeEnough(const SCEVAddRecExpr *AR,
 
 PreservedAnalyses LoopDataPrefetchPass::run(Function &F,
                                             FunctionAnalysisManager &AM) {
+  if (DisableLoopDataPrefetch)
+    return PreservedAnalyses::all();
   DominatorTree *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   LoopInfo *LI = &AM.getResult<LoopAnalysis>(F);
   ScalarEvolution *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
@@ -193,6 +199,8 @@ PreservedAnalyses LoopDataPrefetchPass::run(Function &F,
 }
 
 bool LoopDataPrefetchLegacyPass::runOnFunction(Function &F) {
+  if (DisableLoopDataPrefetch)
+    return false;
   if (skipFunction(F))
     return false;
 
@@ -211,6 +219,9 @@ bool LoopDataPrefetchLegacyPass::runOnFunction(Function &F) {
 }
 
 bool LoopDataPrefetch::run() {
+  if (DisableLoopDataPrefetch)
+    return false;
+
   // If PrefetchDistance is not set, don't run the pass.  This gives an
   // opportunity for targets to run this pass for selected subtargets only
   // (whose TTI sets PrefetchDistance and CacheLineSize).
@@ -272,6 +283,9 @@ struct Prefetch {
 };
 
 bool LoopDataPrefetch::runOnLoop(Loop *L) {
+  if (DisableLoopDataPrefetch)
+    return false;
+
   bool MadeChange = false;
 
   // Only prefetch in the inner-most loop
diff --git a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
index b0b7ae60da98..35fec4156bec 100644
--- a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
@@ -24,6 +24,7 @@
 #include "llvm/Analysis/OptimizationRemarkEmitter.h"
 #include "llvm/Analysis/ScalarEvolution.h"
 #include "llvm/IR/Dominators.h"
+#include "llvm/Support/CommandLine.h"
 
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/Transforms/Scalar/LoopPassManager.h"
@@ -37,6 +38,8 @@ STATISTIC(NumDeleted, "Number of loops deleted");
 STATISTIC(NumBackedgesBroken,
           "Number of loops for which we managed to break the backedge");
 
+static cl::opt<bool> DisableLoopDeletion("disable-pass-loop-deletion", cl::init(false), cl::Hidden, cl::desc("Disable LoopDeletion pass"));
+
 static cl::opt<bool> EnableSymbolicExecution(
     "loop-deletion-enable-symbolic-execution", cl::Hidden, cl::init(true),
     cl::desc("Break backedge through symbolic execution of 1st iteration "
@@ -517,6 +520,8 @@ static LoopDeletionResult deleteLoopIfDead(Loop *L, DominatorTree &DT,
 PreservedAnalyses LoopDeletionPass::run(Loop &L, LoopAnalysisManager &AM,
                                         LoopStandardAnalysisResults &AR,
                                         LPMUpdater &Updater) {
+  if (DisableLoopDeletion)
+    return PreservedAnalyses::all();
 
   LLVM_DEBUG(dbgs() << "Analyzing Loop for deletion: ");
   LLVM_DEBUG(L.dump());
diff --git a/llvm/lib/Transforms/Scalar/LoopFuse.cpp b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
index 8512b2accbe7..0b1b84e765fc 100644
--- a/llvm/lib/Transforms/Scalar/LoopFuse.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
@@ -131,6 +131,10 @@ static cl::opt<bool>
                            cl::Hidden, cl::init(false));
 #endif
 
+static cl::opt<bool> DisableLoopFusion("disable-pass-loop-fusion",
+                                     cl::init(false), cl::Hidden,
+                                     cl::desc("Disable loop fusion"));
+
 namespace {
 /// This class is used to represent a candidate for loop fusion. When it is
 /// constructed, it checks the conditions for loop fusion to ensure that it
@@ -2064,6 +2068,8 @@ private:
 } // namespace
 
 PreservedAnalyses LoopFusePass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableLoopFusion)
+    return PreservedAnalyses::all();
   auto &LI = AM.getResult<LoopAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &DI = AM.getResult<DependenceAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
index 0ee1afa76a82..ed780dda6722 100644
--- a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
@@ -104,6 +104,8 @@ STATISTIC(
 STATISTIC(NumShiftUntilZero,
           "Number of uncountable loops recognized as 'shift until zero' idiom");
 
+static cl::opt<bool> DisableLoopIdiom("disable-pass-loop-idiom", cl::init(false), cl::Hidden, cl::desc("Disable LoopIdiomRecognize pass"));
+
 bool DisableLIRP::All;
 static cl::opt<bool, true>
     DisableLIRPAll("disable-" DEBUG_TYPE "-all",
@@ -255,7 +257,7 @@ private:
 PreservedAnalyses LoopIdiomRecognizePass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &) {
-  if (DisableLIRP::All)
+  if (DisableLoopIdiom || DisableLIRP::All)
     return PreservedAnalyses::all();
 
   const auto *DL = &L.getHeader()->getDataLayout();
@@ -288,6 +290,8 @@ static void deleteDeadInstruction(Instruction *I) {
 //===----------------------------------------------------------------------===//
 
 bool LoopIdiomRecognize::runOnLoop(Loop *L) {
+  if (DisableLoopIdiom)
+    return false;
   CurLoop = L;
   // If the loop could not be converted to canonical form, it must have an
   // indirectbr in it, just give up.
diff --git a/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp b/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
index 270c2120365c..587833ab24e1 100644
--- a/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp
@@ -33,6 +33,7 @@
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/Transforms/Utils/LoopUtils.h"
+#include "llvm/Support/CommandLine.h"
 #include <optional>
 #include <utility>
 
@@ -42,9 +43,15 @@ using namespace llvm;
 
 STATISTIC(NumSimplified, "Number of redundant instructions simplified");
 
+static cl::opt<bool> DisableLoopInstSimplify(
+    "disable-pass-loop-instsimplify", cl::init(false), cl::Hidden,
+    cl::desc("Disable loop instruction simplification"));
+
 static bool simplifyLoopInst(Loop &L, DominatorTree &DT, LoopInfo &LI,
                              AssumptionCache &AC, const TargetLibraryInfo &TLI,
                              MemorySSAUpdater *MSSAU) {
+  if (DisableLoopInstSimplify)
+    return false;
   const DataLayout &DL = L.getHeader()->getDataLayout();
   SimplifyQuery SQ(DL, &TLI, &DT, &AC);
 
@@ -173,6 +180,8 @@ static bool simplifyLoopInst(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses LoopInstSimplifyPass::run(Loop &L, LoopAnalysisManager &AM,
                                             LoopStandardAnalysisResults &AR,
                                             LPMUpdater &) {
+  if (DisableLoopInstSimplify)
+    return PreservedAnalyses::all();
   std::optional<MemorySSAUpdater> MSSAU;
   if (AR.MSSA) {
     MSSAU = MemorySSAUpdater(AR.MSSA);
diff --git a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
index 400973fd9fc9..4970b90927d4 100644
--- a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
@@ -57,6 +57,10 @@ static cl::opt<int> LoopInterchangeCostThreshold(
     "loop-interchange-threshold", cl::init(0), cl::Hidden,
     cl::desc("Interchange if you gain more than this number"));
 
+static cl::opt<bool> DisableLoopInterchange("disable-pass-loop-interchange",
+                                          cl::init(false), cl::Hidden,
+                                          cl::desc("Disable loop interchange"));
+
 namespace {
 
 using LoopVector = SmallVector<Loop *, 8>;
@@ -1283,6 +1287,9 @@ void LoopInterchangeTransform::restructureLoops(
 }
 
 bool LoopInterchangeTransform::transform() {
+  if (DisableLoopInterchange)
+    return false;
+
   bool Transformed = false;
 
   if (InnerLoop->getSubLoops().empty()) {
@@ -1712,6 +1719,8 @@ PreservedAnalyses LoopInterchangePass::run(LoopNest &LN,
                                            LoopAnalysisManager &AM,
                                            LoopStandardAnalysisResults &AR,
                                            LPMUpdater &U) {
+  if (DisableLoopInterchange)
+    return PreservedAnalyses::all();
   Function &F = *LN.getParent();
 
   DependenceInfo DI(&F, &AR.AA, &AR.SE, &AR.LI);
diff --git a/llvm/lib/Transforms/Scalar/LoopPredication.cpp b/llvm/lib/Transforms/Scalar/LoopPredication.cpp
index 027dbb9c0f71..3b95f8a25289 100644
--- a/llvm/lib/Transforms/Scalar/LoopPredication.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopPredication.cpp
@@ -242,6 +242,10 @@ static cl::opt<bool> InsertAssumesOfPredicatedGuardsConditions(
              "predicated guards"),
     cl::init(true));
 
+static cl::opt<bool> DisableLoopPredication("disable-pass-loop-predication",
+                                          cl::init(false), cl::Hidden,
+                                          cl::desc("Disable loop predication"));
+
 namespace {
 /// Represents an induction variable check:
 ///   icmp Pred, <induction variable>, <loop invariant limit>
@@ -332,6 +336,8 @@ public:
 PreservedAnalyses LoopPredicationPass::run(Loop &L, LoopAnalysisManager &AM,
                                            LoopStandardAnalysisResults &AR,
                                            LPMUpdater &U) {
+  if (DisableLoopPredication)
+    return PreservedAnalyses::all();
   std::unique_ptr<MemorySSAUpdater> MSSAU;
   if (AR.MSSA)
     MSSAU = std::make_unique<MemorySSAUpdater>(AR.MSSA);
@@ -1184,6 +1190,9 @@ bool LoopPredication::predicateLoopExits(Loop *L, SCEVExpander &Rewriter) {
 }
 
 bool LoopPredication::runOnLoop(Loop *Loop) {
+  if (DisableLoopPredication)
+    return false;
+
   L = Loop;
 
   LLVM_DEBUG(dbgs() << "Analyzing ");
diff --git a/llvm/lib/Transforms/Scalar/LoopRotation.cpp b/llvm/lib/Transforms/Scalar/LoopRotation.cpp
index acb79e94d087..ed68810d0f85 100644
--- a/llvm/lib/Transforms/Scalar/LoopRotation.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopRotation.cpp
@@ -39,6 +39,8 @@ static cl::opt<bool> PrepareForLTOOption(
     cl::desc("Run loop-rotation in the prepare-for-lto stage. This option "
              "should be used for testing only."));
 
+extern cl::opt<bool> DisableLoopRotation;
+
 LoopRotatePass::LoopRotatePass(bool EnableHeaderDuplication, bool PrepareForLTO)
     : EnableHeaderDuplication(EnableHeaderDuplication),
       PrepareForLTO(PrepareForLTO) {}
@@ -61,6 +63,8 @@ void LoopRotatePass::printPipeline(
 PreservedAnalyses LoopRotatePass::run(Loop &L, LoopAnalysisManager &AM,
                                       LoopStandardAnalysisResults &AR,
                                       LPMUpdater &) {
+  if (DisableLoopRotation)
+    return PreservedAnalyses::all();
   // Vectorization requires loop-rotation. Use default threshold for loops the
   // user explicitly marked for vectorization, even when header duplication is
   // disabled.
diff --git a/llvm/lib/Transforms/Scalar/LoopSink.cpp b/llvm/lib/Transforms/Scalar/LoopSink.cpp
index 6eedf95e7575..b2befe79cd12 100644
--- a/llvm/lib/Transforms/Scalar/LoopSink.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopSink.cpp
@@ -62,6 +62,10 @@ static cl::opt<unsigned> MaxNumberOfUseBBsForSinking(
     "max-uses-for-sinking", cl::Hidden, cl::init(30),
     cl::desc("Do not sink instructions that have too many uses."));
 
+static cl::opt<bool> DisableLoopSink("disable-pass-loop-sink", cl::init(false),
+                                     cl::Hidden,
+                                     cl::desc("Disable loop sinking"));
+
 /// Return adjusted total frequency of \p BBs.
 ///
 /// * If there is only one BB, sinking instruction will not introduce code
@@ -339,6 +343,9 @@ static bool sinkLoopInvariantInstructions(Loop &L, AAResults &AA, LoopInfo &LI,
 }
 
 PreservedAnalyses LoopSinkPass::run(Function &F, FunctionAnalysisManager &FAM) {
+  if (DisableLoopSink)
+    return PreservedAnalyses::all();
+
   // Enable LoopSink only when runtime profile is available.
   // With static profile, the sinking decision may be sub-optimal.
   if (!F.hasProfileData())
diff --git a/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp b/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
index 91461d1ed275..ba5041754d19 100644
--- a/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
@@ -217,6 +217,9 @@ static cl::opt<bool> StressIVChain(
 static bool StressIVChain = false;
 #endif
 
+static cl::opt<bool> DisableLoopStrengthReduce("disable-pass-loop-reduce", cl::init(false),
+                                               cl::Hidden, cl::desc("Disable LoopStrengthReduce pass"));
+
 namespace {
 
 struct MemAccessTy {
@@ -3345,7 +3348,7 @@ void LSRInstance::CollectChains() {
 void LSRInstance::FinalizeChain(IVChain &Chain) {
   assert(!Chain.Incs.empty() && "empty IV chains are not allowed");
   LLVM_DEBUG(dbgs() << "Final Chain: " << *Chain.Incs[0].UserInst << "\n");
-  
+
   for (const IVInc &Inc : Chain) {
     LLVM_DEBUG(dbgs() << "        Inc: " << *Inc.UserInst << "\n");
     auto UseI = find(Inc.UserInst->operands(), Inc.IVOperand);
@@ -6653,7 +6656,7 @@ struct SCEVDbgValueBuilder {
       if (Op.getOp() != dwarf::DW_OP_LLVM_arg) {
         Op.appendToVector(DestExpr);
         continue;
-      } 
+      }
 
       DestExpr.push_back(dwarf::DW_OP_LLVM_arg);
       // `DW_OP_LLVM_arg n` represents the nth LocationOp in this SCEV,
@@ -7247,6 +7250,8 @@ static bool ReduceLoopStrength(Loop *L, IVUsers &IU, ScalarEvolution &SE,
                                const TargetTransformInfo &TTI,
                                AssumptionCache &AC, TargetLibraryInfo &TLI,
                                MemorySSA *MSSA) {
+  if (DisableLoopStrengthReduce)
+    return false;
 
   // Debug preservation - before we start removing anything identify which DVI
   // meet the salvageable criteria and store their DIExpression and SCEVs.
@@ -7400,6 +7405,9 @@ static bool ReduceLoopStrength(Loop *L, IVUsers &IU, ScalarEvolution &SE,
 }
 
 bool LoopStrengthReduce::runOnLoop(Loop *L, LPPassManager & /*LPM*/) {
+  if (DisableLoopStrengthReduce)
+    return false;
+
   if (skipLoop(L))
     return false;
 
@@ -7421,8 +7429,10 @@ bool LoopStrengthReduce::runOnLoop(Loop *L, LPPassManager & /*LPM*/) {
 }
 
 PreservedAnalyses LoopStrengthReducePass::run(Loop &L, LoopAnalysisManager &AM,
-                                              LoopStandardAnalysisResults &AR,
-                                              LPMUpdater &) {
+                                          LoopStandardAnalysisResults &AR,
+                                          LPMUpdater &) {
+  if (DisableLoopStrengthReduce)
+    return PreservedAnalyses::all();
   if (!ReduceLoopStrength(&L, AM.getResult<IVUsersAnalysis>(L, AR), AR.SE,
                           AR.DT, AR.LI, AR.TTI, AR.AC, AR.TLI, AR.MSSA))
     return PreservedAnalyses::all();
diff --git a/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp b/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
index f8e2f1f28088..e069a6fc07da 100644
--- a/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
@@ -85,6 +85,8 @@ static cl::opt<unsigned> PragmaUnrollAndJamThreshold(
     cl::desc("Unrolled size limit for loops with an unroll_and_jam(full) or "
              "unroll_count pragma."));
 
+extern cl::opt<bool> DisableLoopUnrollAndJam;
+
 // Returns the loop hint metadata node with the given name (for example,
 // "llvm.loop.unroll.count").  If no such metadata node exists, then nullptr is
 // returned.
@@ -280,6 +282,9 @@ tryToUnrollAndJamLoop(Loop *L, DominatorTree &DT, LoopInfo *LI,
                       ScalarEvolution &SE, const TargetTransformInfo &TTI,
                       AssumptionCache &AC, DependenceInfo &DI,
                       OptimizationRemarkEmitter &ORE, int OptLevel) {
+  if (DisableLoopUnrollAndJam)
+    return LoopUnrollResult::Unmodified;
+
   TargetTransformInfo::UnrollingPreferences UP = gatherUnrollingPreferences(
       L, SE, TTI, nullptr, nullptr, ORE, OptLevel, std::nullopt, std::nullopt,
       std::nullopt, std::nullopt, std::nullopt, std::nullopt);
@@ -427,6 +432,8 @@ static bool tryToUnrollAndJamLoop(LoopNest &LN, DominatorTree &DT, LoopInfo &LI,
                                   AssumptionCache &AC, DependenceInfo &DI,
                                   OptimizationRemarkEmitter &ORE, int OptLevel,
                                   LPMUpdater &U) {
+  if (DisableLoopUnrollAndJam)
+    return false;
   bool DidSomething = false;
   ArrayRef<Loop *> Loops = LN.getLoops();
   Loop *OutmostLoop = &LN.getOutermostLoop();
@@ -453,6 +460,8 @@ PreservedAnalyses LoopUnrollAndJamPass::run(LoopNest &LN,
                                             LoopAnalysisManager &AM,
                                             LoopStandardAnalysisResults &AR,
                                             LPMUpdater &U) {
+  if (DisableLoopUnrollAndJam)
+    return PreservedAnalyses::all();
   Function &F = *LN.getParent();
 
   DependenceInfo DI(&F, &AR.AA, &AR.SE, &AR.LI);
diff --git a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
index cbc35b6dd429..b3f97d163d2c 100644
--- a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
@@ -179,6 +179,13 @@ static cl::opt<unsigned> PragmaUnrollFullMaxIterations(
     "pragma-unroll-full-max-iterations", cl::init(1'000'000), cl::Hidden,
     cl::desc("Maximum allowed iterations to unroll under pragma unroll full."));
 
+cl::opt<bool> DisableLoopUnroll("disable-pass-loop-unroll", cl::init(false),
+                                cl::Hidden,
+                                cl::desc("Disable LoopUnroll pass"));
+
+static cl::opt<bool> DisableLoopFullUnroll("disable-pass-loop-unroll-full", cl::init(false),
+                                           cl::Hidden, cl::desc("Disable LoopFullUnroll pass"));
+
 /// A magic value for use with the Threshold parameter to indicate
 /// that the loop unroll should be performed regardless of how much
 /// code expansion would result.
@@ -1432,6 +1439,8 @@ public:
   }
 
   bool runOnLoop(Loop *L, LPPassManager &LPM) override {
+    if (DisableLoopUnroll)
+      return false;
     if (skipLoop(L))
       return false;
 
@@ -1503,6 +1512,8 @@ Pass *llvm::createLoopUnrollPass(int OptLevel, bool OnlyWhenForced,
 PreservedAnalyses LoopFullUnrollPass::run(Loop &L, LoopAnalysisManager &AM,
                                           LoopStandardAnalysisResults &AR,
                                           LPMUpdater &Updater) {
+  if (DisableLoopFullUnroll)
+    return PreservedAnalyses::all();
   // For the new PM, we can't use OptimizationRemarkEmitter as an analysis
   // pass. Function analyses need to be preserved across loop transformations
   // but ORE cannot be preserved (see comment before the pass definition).
@@ -1588,6 +1599,8 @@ PreservedAnalyses LoopFullUnrollPass::run(Loop &L, LoopAnalysisManager &AM,
 
 PreservedAnalyses LoopUnrollPass::run(Function &F,
                                       FunctionAnalysisManager &AM) {
+  if (DisableLoopUnroll)
+    return PreservedAnalyses::all();
   auto &LI = AM.getResult<LoopAnalysis>(F);
   // There are no loops in the function. Return before computing other expensive
   // analyses.
diff --git a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
index 663715948241..fc4a60352d2a 100644
--- a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
@@ -108,6 +108,10 @@ static cl::opt<unsigned> LVLoopDepthThreshold(
         "LoopVersioningLICM's threshold for maximum allowed loop nest/depth"),
     cl::init(2), cl::Hidden);
 
+static cl::opt<bool> DisableLoopVersioningLICM(
+    "disable-pass-loop-versioning-licm", cl::init(false), cl::Hidden,
+    cl::desc("Disable loop versioning for LICM"));
+
 namespace {
 
 struct LoopVersioningLICM {
@@ -539,6 +543,8 @@ void LoopVersioningLICM::setNoAliasToLoop(Loop *VerLoop) {
 }
 
 bool LoopVersioningLICM::run(DominatorTree *DT) {
+  if (DisableLoopVersioningLICM)
+    return false;
   // Do not do the transformation if disabled by metadata.
   if (hasLICMVersioningTransformation(CurLoop) & TM_Disable)
     return false;
@@ -576,6 +582,8 @@ namespace llvm {
 PreservedAnalyses LoopVersioningLICMPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &LAR,
                                               LPMUpdater &U) {
+  if (DisableLoopVersioningLICM)
+    return PreservedAnalyses::all();
   AliasAnalysis *AA = &LAR.AA;
   ScalarEvolution *SE = &LAR.SE;
   DominatorTree *DT = &LAR.DT;
diff --git a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
index cee34f0a6da1..23723b4e994b 100644
--- a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
+++ b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
@@ -55,6 +55,7 @@
 #include "llvm/Support/MathExtras.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Support/CommandLine.h"
 #include <algorithm>
 #include <cassert>
 #include <cstdint>
@@ -68,6 +69,9 @@ static cl::opt<bool> EnableMemCpyOptWithoutLibcalls(
     "enable-memcpyopt-without-libcalls", cl::Hidden,
     cl::desc("Enable memcpyopt even when libcalls are disabled"));
 
+static cl::opt<bool> DisableMemCpyOpt("disable-pass-memcpyopt", cl::init(false),
+                                      cl::Hidden, cl::desc("Disable MemCpyOpt pass"));
+
 STATISTIC(NumMemCpyInstr, "Number of memcpy instructions deleted");
 STATISTIC(NumMemSetInfer, "Number of memsets inferred");
 STATISTIC(NumMoveToCpy, "Number of memmoves converted to memcpy");
@@ -1723,6 +1727,8 @@ static bool isZeroSize(Value *Size) {
 /// circumstances). This allows later passes to remove the first memcpy
 /// altogether.
 bool MemCpyOptPass::processMemCpy(MemCpyInst *M, BasicBlock::iterator &BBI) {
+  if (DisableMemCpyOpt)
+    return false;
   // We can only optimize non-volatile memcpy's.
   if (M->isVolatile())
     return false;
@@ -2091,6 +2097,8 @@ bool MemCpyOptPass::iterateOnFunction(Function &F) {
 }
 
 PreservedAnalyses MemCpyOptPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableMemCpyOpt)
+    return PreservedAnalyses::all();
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto *AA = &AM.getResult<AAManager>(F);
   auto *AC = &AM.getResult<AssumptionAnalysis>(F);
@@ -2102,16 +2110,18 @@ PreservedAnalyses MemCpyOptPass::run(Function &F, FunctionAnalysisManager &AM) {
   if (!MadeChange)
     return PreservedAnalyses::all();
 
-  PreservedAnalyses PA;
-  PA.preserveSet<CFGAnalyses>();
-  PA.preserve<MemorySSAAnalysis>();
-  return PA;
+    PreservedAnalyses PA;
+    PA.preserveSet<CFGAnalyses>();
+    PA.preserve<MemorySSAAnalysis>();
+    return PA;
 }
 
 bool MemCpyOptPass::runImpl(Function &F, TargetLibraryInfo *TLI_,
                             AliasAnalysis *AA_, AssumptionCache *AC_,
                             DominatorTree *DT_, PostDominatorTree *PDT_,
                             MemorySSA *MSSA_) {
+  if (DisableMemCpyOpt)
+    return false;
   bool MadeChange = false;
   TLI = TLI_;
   AA = AA_;
diff --git a/llvm/lib/Transforms/Scalar/MergeICmps.cpp b/llvm/lib/Transforms/Scalar/MergeICmps.cpp
index 4291f3aee0cd..c0bf063e1427 100644
--- a/llvm/lib/Transforms/Scalar/MergeICmps.cpp
+++ b/llvm/lib/Transforms/Scalar/MergeICmps.cpp
@@ -66,6 +66,10 @@ using namespace llvm;
 
 namespace {
 
+static cl::opt<bool> DisableMergeICmps("disable-pass-mergeicmps",
+                                       cl::init(false), cl::Hidden,
+                                       cl::desc("Disable merging of icmps"));
+
 #define DEBUG_TYPE "mergeicmps"
 
 // A BCE atom "Binary Compare Expression Atom" represents an integer load
@@ -845,6 +849,8 @@ bool processPhi(PHINode &Phi, const TargetLibraryInfo &TLI, AliasAnalysis &AA,
 static bool runImpl(Function &F, const TargetLibraryInfo &TLI,
                     const TargetTransformInfo &TTI, AliasAnalysis &AA,
                     DominatorTree *DT) {
+  if (DisableMergeICmps)
+    return false;
   LLVM_DEBUG(dbgs() << "MergeICmpsLegacyPass: " << F.getName() << "\n");
 
   // We only try merging comparisons if the target wants to expand memcmp later.
@@ -879,6 +885,9 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableMergeICmps)
+      return false;
+
     if (skipFunction(F)) return false;
     const auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
     const auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);
@@ -914,6 +923,9 @@ Pass *llvm::createMergeICmpsLegacyPass() { return new MergeICmpsLegacyPass(); }
 
 PreservedAnalyses MergeICmpsPass::run(Function &F,
                                       FunctionAnalysisManager &AM) {
+  if (DisableMergeICmps)
+    return PreservedAnalyses::all();
+
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   auto &AA = AM.getResult<AAManager>(F);
diff --git a/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp b/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
index 299239fb7020..e3d4b2ac7119 100644
--- a/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
+++ b/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
@@ -84,12 +84,17 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Support/CommandLine.h"
 
 using namespace llvm;
 
 #define DEBUG_TYPE "mldst-motion"
 
 namespace {
+
+static cl::opt<bool> DisableMLDSTMotion("disable-pass-mldst-motion",
+                                        cl::init(false), cl::Hidden,
+                                        cl::desc("Disable merged load/store motion"));
 //===----------------------------------------------------------------------===//
 //                         MergedLoadStoreMotion Pass
 //===----------------------------------------------------------------------===//
@@ -360,6 +365,9 @@ bool MergedLoadStoreMotion::mergeStores(BasicBlock *HeadBB) {
 }
 
 bool MergedLoadStoreMotion::run(Function &F, AliasAnalysis &AA) {
+  if (DisableMLDSTMotion)
+    return false;
+
   this->AA = &AA;
 
   bool Changed = false;
@@ -367,7 +375,7 @@ bool MergedLoadStoreMotion::run(Function &F, AliasAnalysis &AA) {
 
   // Merge unconditional branches, allowing PRE to catch more
   // optimization opportunities.
-  // This loop doesn't care about newly inserted/split blocks 
+  // This loop doesn't care about newly inserted/split blocks
   // since they never will be diamond heads.
   for (BasicBlock &BB : make_early_inc_range(F))
     // Hoist equivalent loads and sink stores
@@ -379,6 +387,8 @@ bool MergedLoadStoreMotion::run(Function &F, AliasAnalysis &AA) {
 
 PreservedAnalyses
 MergedLoadStoreMotionPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableMLDSTMotion)
+    return PreservedAnalyses::all();
   MergedLoadStoreMotion Impl(Options.SplitFooterBB);
   auto &AA = AM.getResult<AAManager>(F);
   if (!Impl.run(F, AA))
diff --git a/llvm/lib/Transforms/Scalar/NewGVN.cpp b/llvm/lib/Transforms/Scalar/NewGVN.cpp
index fc0b31c43396..bf13483d47e4 100644
--- a/llvm/lib/Transforms/Scalar/NewGVN.cpp
+++ b/llvm/lib/Transforms/Scalar/NewGVN.cpp
@@ -154,6 +154,9 @@ static cl::opt<bool> EnableStoreRefinement("enable-store-refinement",
 static cl::opt<bool> EnablePhiOfOps("enable-phi-of-ops", cl::init(true),
                                     cl::Hidden);
 
+static cl::opt<bool> DisableNewGVN("disable-pass-newgvn", cl::init(false),
+                                   cl::Hidden, cl::desc("Disable NewGVN pass"));
+
 //===----------------------------------------------------------------------===//
 //                                GVN Pass
 //===----------------------------------------------------------------------===//
@@ -3425,6 +3428,9 @@ void NewGVN::iterateTouchedInstructions() {
 
 // This is the main transformation entry point.
 bool NewGVN::runGVN() {
+  if (DisableNewGVN)
+    return false;
+
   if (DebugCounter::isCounterSet(VNCounter))
     StartingVNCounter = DebugCounter::getCounterState(VNCounter);
   bool Changed = false;
@@ -4233,6 +4239,8 @@ bool NewGVN::shouldSwapOperandsForIntrinsic(const Value *A, const Value *B,
 }
 
 PreservedAnalyses NewGVNPass::run(Function &F, AnalysisManager<Function> &AM) {
+  if (DisableNewGVN)
+    return PreservedAnalyses::all();
   // Apparently the order in which we get these results matter for
   // the old GVN (see Chandler's comment in GVN.cpp). I'll keep
   // the same order here, just in case.
diff --git a/llvm/lib/Transforms/Scalar/PartiallyInlineLibCalls.cpp b/llvm/lib/Transforms/Scalar/PartiallyInlineLibCalls.cpp
index 3a699df1cde4..280e2f047330 100644
--- a/llvm/lib/Transforms/Scalar/PartiallyInlineLibCalls.cpp
+++ b/llvm/lib/Transforms/Scalar/PartiallyInlineLibCalls.cpp
@@ -19,6 +19,7 @@
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/InitializePasses.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/DebugCounter.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
@@ -31,6 +32,10 @@ using namespace llvm;
 DEBUG_COUNTER(PILCounter, "partially-inline-libcalls-transform",
               "Controls transformations in partially-inline-libcalls");
 
+static cl::opt<bool> DisablePartiallyInlineLibCalls(
+    "disable-pass-partially-inline-libcalls", cl::init(false), cl::Hidden,
+    cl::desc("Disable partially inlining of library calls"));
+
 static bool optimizeSQRT(CallInst *Call, Function *CalledFunc,
                          BasicBlock &CurrBB, Function::iterator &BB,
                          const TargetTransformInfo *TTI, DomTreeUpdater *DTU) {
@@ -104,6 +109,8 @@ static bool optimizeSQRT(CallInst *Call, Function *CalledFunc,
 static bool runPartiallyInlineLibCalls(Function &F, TargetLibraryInfo *TLI,
                                        const TargetTransformInfo *TTI,
                                        DominatorTree *DT) {
+  if (DisablePartiallyInlineLibCalls)
+    return false;
   std::optional<DomTreeUpdater> DTU;
   if (DT)
     DTU.emplace(DT, DomTreeUpdater::UpdateStrategy::Lazy);
@@ -185,6 +192,9 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePartiallyInlineLibCalls)
+      return false;
+
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/Reassociate.cpp b/llvm/lib/Transforms/Scalar/Reassociate.cpp
index e742d2ed12af..c4a6b42ed5eb 100644
--- a/llvm/lib/Transforms/Scalar/Reassociate.cpp
+++ b/llvm/lib/Transforms/Scalar/Reassociate.cpp
@@ -71,6 +71,8 @@ STATISTIC(NumChanged, "Number of insts reassociated");
 STATISTIC(NumAnnihil, "Number of expr tree annihilated");
 STATISTIC(NumFactor , "Number of multiplies factored");
 
+static cl::opt<bool> DisableReassociate("disable-pass-reassociate", cl::init(false), cl::Hidden, cl::desc("Disable Reassociate pass"));
+
 static cl::opt<bool>
     UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",
                    cl::desc("Only reorder expressions within a basic block "
@@ -976,7 +978,7 @@ static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {
 /// Return true if we should break up this subtract of X-Y into (X + -Y).
 static bool ShouldBreakUpSubtract(Instruction *Sub) {
   // If this is a negation, we can't split it up!
-  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) 
+  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value())))
     return false;
 
   // Don't breakup X - undef.
@@ -2542,6 +2544,8 @@ ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {
 }
 
 PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {
+  if (DisableReassociate)
+    return PreservedAnalyses::all();
   // Get the functions basic blocks in Reverse Post Order. This order is used by
   // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic
   // blocks (it has been seen that the analysis in this pass could hang when
@@ -2632,6 +2636,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisableReassociate)
+        return false;
+
       if (skipFunction(F))
         return false;
 
diff --git a/llvm/lib/Transforms/Scalar/Reg2Mem.cpp b/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
index ebc5075aa36f..95782325a81e 100644
--- a/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
+++ b/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
@@ -25,6 +25,7 @@
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/PassManager.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
@@ -37,6 +38,8 @@ using namespace llvm;
 STATISTIC(NumRegsDemoted, "Number of registers demoted");
 STATISTIC(NumPhisDemoted, "Number of phi-nodes demoted");
 
+static cl::opt<bool> DisableReg2Mem("disable-pass-reg2mem", cl::init(false), cl::Hidden, cl::desc("Disable Reg2Mem pass"));
+
 static bool valueEscapes(const Instruction &Inst) {
   if (!Inst.getType()->isSized())
     return false;
@@ -51,6 +54,9 @@ static bool valueEscapes(const Instruction &Inst) {
 }
 
 static bool runPass(Function &F) {
+  if (DisableReg2Mem)
+    return false;
+
   // Insert all new allocas into entry block.
   BasicBlock *BBEntry = &F.getEntryBlock();
   assert(pred_empty(BBEntry) &&
@@ -94,6 +100,8 @@ static bool runPass(Function &F) {
 }
 
 PreservedAnalyses RegToMemPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableReg2Mem)
+    return PreservedAnalyses::all();
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *LI = &AM.getResult<LoopAnalysis>(F);
   unsigned N = SplitAllCriticalEdges(F, CriticalEdgeSplittingOptions(DT, LI));
diff --git a/llvm/lib/Transforms/Scalar/SCCP.cpp b/llvm/lib/Transforms/Scalar/SCCP.cpp
index ce45c58e624e..2b797552a11c 100644
--- a/llvm/lib/Transforms/Scalar/SCCP.cpp
+++ b/llvm/lib/Transforms/Scalar/SCCP.cpp
@@ -46,6 +46,7 @@
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/Transforms/Utils/SCCPSolver.h"
+#include "llvm/Support/CommandLine.h"
 #include <utility>
 
 using namespace llvm;
@@ -57,10 +58,15 @@ STATISTIC(NumDeadBlocks , "Number of basic blocks unreachable");
 STATISTIC(NumInstReplaced,
           "Number of instructions replaced with (simpler) instruction");
 
+static cl::opt<bool> DisableSCCP("disable-pass-sccp", cl::init(false), cl::Hidden,
+                               cl::desc("Disable SCCP pass"));
+
 // runSCCP() - Run the Sparse Conditional Constant Propagation algorithm,
 // and return true if the function was modified.
 static bool runSCCP(Function &F, const DataLayout &DL,
                     const TargetLibraryInfo *TLI, DomTreeUpdater &DTU) {
+  if (DisableSCCP)
+    return false;
   LLVM_DEBUG(dbgs() << "SCCP on function '" << F.getName() << "'\n");
   SCCPSolver Solver(
       DL, [TLI](Function &F) -> const TargetLibraryInfo & { return *TLI; },
@@ -119,6 +125,9 @@ static bool runSCCP(Function &F, const DataLayout &DL,
 }
 
 PreservedAnalyses SCCPPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableSCCP)
+    return PreservedAnalyses::all();
+
   const DataLayout &DL = F.getDataLayout();
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto *DT = AM.getCachedResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/SROA.cpp b/llvm/lib/Transforms/Scalar/SROA.cpp
index c738a2a6f39a..92bcfcbbcbfd 100644
--- a/llvm/lib/Transforms/Scalar/SROA.cpp
+++ b/llvm/lib/Transforms/Scalar/SROA.cpp
@@ -119,6 +119,9 @@ STATISTIC(NumVectorized, "Number of vectorized aggregates");
 /// Disable running mem2reg during SROA in order to test or debug SROA.
 static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),
                                      cl::Hidden);
+
+static cl::opt<bool> DisableSROA("disable-pass-sroa", cl::init(false), cl::Hidden,
+                               cl::desc("Disable SROA pass"));
 namespace {
 
 class AllocaSliceRewriter;
@@ -5569,6 +5572,8 @@ bool SROA::promoteAllocas(Function &F) {
 }
 
 std::pair<bool /*Changed*/, bool /*CFGChanged*/> SROA::runSROA(Function &F) {
+  if (DisableSROA)
+    return {false, false};
   LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");
 
   const DataLayout &DL = F.getDataLayout();
@@ -5630,6 +5635,8 @@ std::pair<bool /*Changed*/, bool /*CFGChanged*/> SROA::runSROA(Function &F) {
 }
 
 PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableSROA)
+    return PreservedAnalyses::all();
   DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);
   AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);
   DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Lazy);
@@ -5669,6 +5676,8 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableSROA)
+      return false;
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp b/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
index 73e3ff296cf1..90f994a0fa95 100644
--- a/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
+++ b/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
@@ -1163,6 +1163,8 @@ bool SeparateConstOffsetFromGEP::splitGEP(GetElementPtrInst *GEP) {
 }
 
 bool SeparateConstOffsetFromGEPLegacyPass::runOnFunction(Function &F) {
+  if (DisableSeparateConstOffsetFromGEP)
+    return false;
   if (skipFunction(F))
     return false;
   auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
@@ -1399,6 +1401,8 @@ void SeparateConstOffsetFromGEPPass::printPipeline(
 
 PreservedAnalyses
 SeparateConstOffsetFromGEPPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableSeparateConstOffsetFromGEP)
+    return PreservedAnalyses::all();
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *LI = &AM.getResult<LoopAnalysis>(F);
   auto *TLI = &AM.getResult<TargetLibraryAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index f99f4487c554..0edb6e07b931 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -134,6 +134,9 @@ static cl::opt<unsigned> InjectInvariantConditionHotnesThreshold(
                          "not-taken 1/<this option> times or less."),
     cl::init(16));
 
+static cl::opt<bool> DisableSimpleLoopUnswitch("disable-pass-simple-loop-unswitch", cl::init(false),
+                                               cl::Hidden, cl::desc("Disable SimpleLoopUnswitch pass"));
+
 AnalysisKey ShouldRunExtraSimpleLoopUnswitch::Key;
 namespace {
 struct CompareDesc {
@@ -3589,6 +3592,8 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
                          bool NonTrivial, ScalarEvolution *SE,
                          MemorySSAUpdater *MSSAU, ProfileSummaryInfo *PSI,
                          BlockFrequencyInfo *BFI, LPMUpdater &LoopUpdater) {
+  if (DisableSimpleLoopUnswitch)
+    return false;
   assert(L.isRecursivelyLCSSAForm(DT, LI) &&
          "Loops must be in LCSSA form before unswitching.");
 
@@ -3681,6 +3686,8 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
+  if (DisableSimpleLoopUnswitch)
+    return PreservedAnalyses::all();
   Function &F = *L.getHeader()->getParent();
   (void)F;
   ProfileSummaryInfo *PSI = nullptr;
diff --git a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
index 11de37f7a7c1..7701cfe76e81 100644
--- a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
+++ b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
@@ -81,6 +81,9 @@ static cl::opt<bool> UserSpeculateUnpredictables(
     "speculate-unpredictables", cl::Hidden, cl::init(false),
     cl::desc("Speculate unpredictable branches (default = false)"));
 
+static cl::opt<bool> DisableSimplifyCFG("disable-pass-simplifycfg", cl::init(false),
+                                        cl::Hidden, cl::desc("Disable SimplifyCFG pass"));
+
 STATISTIC(NumSimpl, "Number of blocks simplified");
 
 static bool
@@ -270,6 +273,8 @@ static bool iterativelySimplifyCFG(Function &F, const TargetTransformInfo &TTI,
 static bool simplifyFunctionCFGImpl(Function &F, const TargetTransformInfo &TTI,
                                     DominatorTree *DT,
                                     const SimplifyCFGOptions &Options) {
+  if (DisableSimplifyCFG)
+    return false;
   DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Eager);
 
   bool EverChanged = removeUnreachableBlocks(F, DT ? &DTU : nullptr);
@@ -364,6 +369,8 @@ void SimplifyCFGPass::printPipeline(
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisableSimplifyCFG)
+    return PreservedAnalyses::all();
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   DominatorTree *DT = nullptr;
@@ -394,6 +401,8 @@ struct CFGSimplifyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableSimplifyCFG)
+      return false;
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
 
diff --git a/llvm/lib/Transforms/Scalar/Sink.cpp b/llvm/lib/Transforms/Scalar/Sink.cpp
index 46bcfd6b41ce..cdd8b50e548a 100644
--- a/llvm/lib/Transforms/Scalar/Sink.cpp
+++ b/llvm/lib/Transforms/Scalar/Sink.cpp
@@ -17,6 +17,7 @@
 #include "llvm/Analysis/LoopInfo.h"
 #include "llvm/IR/Dominators.h"
 #include "llvm/InitializePasses.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/Scalar.h"
@@ -27,6 +28,10 @@ using namespace llvm;
 STATISTIC(NumSunk, "Number of instructions sunk");
 STATISTIC(NumSinkIter, "Number of sinking iterations");
 
+static cl::opt<bool> DisableSinking("disable-pass-sink", cl::init(false),
+                                    cl::Hidden,
+                                    cl::desc("Disable sinking pass"));
+
 static bool isSafeToMove(Instruction *Inst, AliasAnalysis &AA,
                          SmallPtrSetImpl<Instruction *> &Stores) {
 
@@ -102,6 +107,8 @@ static bool IsAcceptableTarget(Instruction *Inst, BasicBlock *SuccToSinkTo,
 static bool SinkInstruction(Instruction *Inst,
                             SmallPtrSetImpl<Instruction *> &Stores,
                             DominatorTree &DT, LoopInfo &LI, AAResults &AA) {
+  if (DisableSinking)
+    return false;
 
   // Don't sink static alloca instructions.  CodeGen assumes allocas outside the
   // entry block are dynamically sized stack objects.
@@ -174,6 +181,8 @@ static bool SinkInstruction(Instruction *Inst,
 
 static bool ProcessBlock(BasicBlock &BB, DominatorTree &DT, LoopInfo &LI,
                          AAResults &AA) {
+  if (DisableSinking)
+    return false;
   // Don't bother sinking code out of unreachable blocks. In addition to being
   // unprofitable, it can also lead to infinite looping, because in an
   // unreachable loop there may be nowhere to stop.
@@ -211,6 +220,8 @@ static bool ProcessBlock(BasicBlock &BB, DominatorTree &DT, LoopInfo &LI,
 
 static bool iterativelySinkInstructions(Function &F, DominatorTree &DT,
                                         LoopInfo &LI, AAResults &AA) {
+  if (DisableSinking)
+    return false;
   bool MadeChange, EverMadeChange = false;
 
   do {
@@ -227,6 +238,8 @@ static bool iterativelySinkInstructions(Function &F, DominatorTree &DT,
 }
 
 PreservedAnalyses SinkingPass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableSinking)
+    return PreservedAnalyses::all();
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &LI = AM.getResult<LoopAnalysis>(F);
   auto &AA = AM.getResult<AAManager>(F);
@@ -248,6 +261,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisableSinking)
+        return false;
+
       auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
       auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
       auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();
diff --git a/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp b/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
index ed9c1828ce06..61880f958201 100644
--- a/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
+++ b/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
@@ -100,6 +100,10 @@ static cl::opt<bool> SpecExecOnlyIfDivergentTarget(
              "branches, even if the pass was configured to apply only to all "
              "targets."));
 
+static cl::opt<bool> DisableSpeculativeExecution(
+    "disable-pass-speculative-execution", cl::init(false), cl::Hidden,
+    cl::desc("Disable speculative execution pass"));
+
 namespace {
 
 class SpeculativeExecutionLegacyPass : public FunctionPass {
@@ -152,6 +156,8 @@ bool SpeculativeExecutionLegacyPass::runOnFunction(Function &F) {
 namespace llvm {
 
 bool SpeculativeExecutionPass::runImpl(Function &F, TargetTransformInfo *TTI) {
+  if (DisableSpeculativeExecution)
+    return false;
   if (OnlyIfDivergentTarget && !TTI->hasBranchDivergence(&F)) {
     LLVM_DEBUG(dbgs() << "Not running SpeculativeExecution because "
                          "TTI->hasBranchDivergence() is false.\n");
@@ -167,6 +173,8 @@ bool SpeculativeExecutionPass::runImpl(Function &F, TargetTransformInfo *TTI) {
 }
 
 bool SpeculativeExecutionPass::runOnBasicBlock(BasicBlock &B) {
+  if (DisableSpeculativeExecution)
+    return false;
   BranchInst *BI = dyn_cast<BranchInst>(B.getTerminator());
   if (BI == nullptr)
     return false;
diff --git a/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp b/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
index 75585fcc8026..93981cd02809 100644
--- a/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
+++ b/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
@@ -81,6 +81,7 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Support/CommandLine.h"
 #include <cassert>
 #include <cstdint>
 #include <limits>
@@ -93,6 +94,10 @@ using namespace PatternMatch;
 static const unsigned UnknownAddressSpace =
     std::numeric_limits<unsigned>::max();
 
+static cl::opt<bool> DisableSLSR("disable-pass-slsr", cl::init(false),
+                                 cl::Hidden,
+                                 cl::desc("Disable straight-line strength reduction"));
+
 namespace {
 
 class StraightLineStrengthReduceLegacyPass : public FunctionPass {
@@ -669,6 +674,9 @@ void StraightLineStrengthReduce::rewriteCandidateWithBasis(
 }
 
 bool StraightLineStrengthReduceLegacyPass::runOnFunction(Function &F) {
+  if (DisableSLSR)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -679,6 +687,8 @@ bool StraightLineStrengthReduceLegacyPass::runOnFunction(Function &F) {
 }
 
 bool StraightLineStrengthReduce::runOnFunction(Function &F) {
+  if (DisableSLSR)
+    return false;
   // Traverse the dominator tree in the depth-first order. This order makes sure
   // all bases of a candidate are in Candidates when we process it.
   for (const auto Node : depth_first(DT))
@@ -713,6 +723,9 @@ namespace llvm {
 
 PreservedAnalyses
 StraightLineStrengthReducePass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableSLSR)
+    return PreservedAnalyses::all();
+
   const DataLayout *DL = &F.getDataLayout();
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
index 1b3e6d9549b8..8cd253571430 100644
--- a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
+++ b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
@@ -87,6 +87,10 @@ STATISTIC(NumEliminated, "Number of tail calls removed");
 STATISTIC(NumRetDuped,   "Number of return duplicated");
 STATISTIC(NumAccumAdded, "Number of accumulators introduced");
 
+static cl::opt<bool> DisableTailCallElim("disable-pass-tailcallelim",
+                                         cl::init(false), cl::Hidden,
+                                         cl::desc("Disable tail call elimination"));
+
 /// Scan the specified function for alloca instructions.
 /// If it contains any dynamic allocas, returns false.
 static bool canTRE(Function &F) {
@@ -864,6 +868,8 @@ bool TailRecursionEliminator::eliminate(Function &F,
                                         AliasAnalysis *AA,
                                         OptimizationRemarkEmitter *ORE,
                                         DomTreeUpdater &DTU) {
+  if (DisableTailCallElim)
+    return false;
   if (F.getFnAttribute("disable-tail-calls").getValueAsBool())
     return false;
 
@@ -906,6 +912,9 @@ struct TailCallElim : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisableTailCallElim)
+      return false;
+
     if (skipFunction(F))
       return false;
 
@@ -942,6 +951,9 @@ FunctionPass *llvm::createTailCallEliminationPass() {
 PreservedAnalyses TailCallElimPass::run(Function &F,
                                         FunctionAnalysisManager &AM) {
 
+  if (DisableTailCallElim)
+    return PreservedAnalyses::all();
+
   TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);
   AliasAnalysis &AA = AM.getResult<AAManager>(F);
   auto &ORE = AM.getResult<OptimizationRemarkEmitterAnalysis>(F);
diff --git a/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp b/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
index 4606514cbc71..7ad72e1986bd 100644
--- a/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
+++ b/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
@@ -28,6 +28,7 @@
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/InitializePasses.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
 #include "llvm/Transforms/Utils/Cloning.h"
@@ -38,6 +39,8 @@ using namespace llvm;
 
 STATISTIC(NumBroken, "Number of blocks inserted");
 
+static cl::opt<bool> DisableBreakCritEdges("disable-pass-break-crit-edges", cl::init(false), cl::Hidden, cl::desc("Disable BreakCriticalEdges pass"));
+
 namespace {
   struct BreakCriticalEdges : public FunctionPass {
     static char ID; // Pass identification, replacement for typeid
@@ -46,6 +49,8 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisableBreakCritEdges)
+        return false;
       auto *DTWP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();
       auto *DT = DTWP ? &DTWP->getDomTree() : nullptr;
 
@@ -82,6 +87,8 @@ FunctionPass *llvm::createBreakCriticalEdgesPass() {
 
 PreservedAnalyses BreakCriticalEdgesPass::run(Function &F,
                                               FunctionAnalysisManager &AM) {
+  if (DisableBreakCritEdges)
+    return PreservedAnalyses::all();
   auto *DT = AM.getCachedResult<DominatorTreeAnalysis>(F);
   auto *LI = AM.getCachedResult<LoopAnalysis>(F);
   unsigned N = SplitAllCriticalEdges(F, CriticalEdgeSplittingOptions(DT, LI));
diff --git a/llvm/lib/Transforms/Utils/LCSSA.cpp b/llvm/lib/Transforms/Utils/LCSSA.cpp
index ab1edf47d8db..45887824b426 100644
--- a/llvm/lib/Transforms/Utils/LCSSA.cpp
+++ b/llvm/lib/Transforms/Utils/LCSSA.cpp
@@ -65,6 +65,9 @@ static cl::opt<bool, true>
                         cl::Hidden,
                         cl::desc("Verify loop lcssa form (time consuming)"));
 
+static cl::opt<bool> DisableLCSSA("disable-pass-lcssa", cl::init(false),
+                                  cl::Hidden, cl::desc("Disable LCSSA pass"));
+
 /// Return true if the specified block is in the list.
 static bool isExitBlock(BasicBlock *BB,
                         const SmallVectorImpl<BasicBlock *> &ExitBlocks) {
@@ -508,6 +511,9 @@ char &llvm::LCSSAID = LCSSAWrapperPass::ID;
 
 /// Transform \p F into loop-closed SSA form.
 bool LCSSAWrapperPass::runOnFunction(Function &F) {
+  //   if (DisableLCSSA)
+  //     return false;
+
   LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
   DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   auto *SEWP = getAnalysisIfAvailable<ScalarEvolutionWrapperPass>();
@@ -517,6 +523,9 @@ bool LCSSAWrapperPass::runOnFunction(Function &F) {
 }
 
 PreservedAnalyses LCSSAPass::run(Function &F, FunctionAnalysisManager &AM) {
+  //   if (DisableLCSSA)
+  //     return PreservedAnalyses::all();
+
   auto &LI = AM.getResult<LoopAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = AM.getCachedResult<ScalarEvolutionAnalysis>(F);
diff --git a/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp b/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
index 9fe655e548c2..f507691e25e2 100644
--- a/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
+++ b/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
@@ -49,6 +49,8 @@ using namespace llvm;
 STATISTIC(NumWrappedOneCond, "Number of One-Condition Wrappers Inserted");
 STATISTIC(NumWrappedTwoCond, "Number of Two-Condition Wrappers Inserted");
 
+static cl::opt<bool> DisableLibCallsShrinkWrap("disable-pass-libcalls-shrinkwrap", cl::init(false), cl::Hidden, cl::desc("Disable LibCallsShrinkWrap pass"));
+
 namespace {
 class LibCallsShrinkWrap : public InstVisitor<LibCallsShrinkWrap> {
 public:
@@ -498,6 +500,8 @@ bool LibCallsShrinkWrap::perform(CallInst *CI) {
 
 static bool runImpl(Function &F, const TargetLibraryInfo &TLI,
                     DominatorTree *DT) {
+  if (DisableLibCallsShrinkWrap)
+    return false;
   if (F.hasFnAttribute(Attribute::OptimizeForSize))
     return false;
   DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Lazy);
@@ -513,6 +517,8 @@ static bool runImpl(Function &F, const TargetLibraryInfo &TLI,
 
 PreservedAnalyses LibCallsShrinkWrapPass::run(Function &F,
                                               FunctionAnalysisManager &FAM) {
+  if (DisableLibCallsShrinkWrap)
+    return PreservedAnalyses::all();
   auto &TLI = FAM.getResult<TargetLibraryAnalysis>(F);
   auto *DT = FAM.getCachedResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT))
diff --git a/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp b/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
index 04042e71a2b8..9a3b7cf4d198 100644
--- a/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
+++ b/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
@@ -52,6 +52,10 @@ static cl::opt<bool>
                 cl::desc("Allow loop rotation multiple times in order to reach "
                          "a better latch exit"));
 
+cl::opt<bool> DisableLoopRotation("disable-pass-loop-rotate", cl::init(false),
+                                  cl::Hidden,
+                                  cl::desc("Disable LoopRotation pass"));
+
 // Probability that a rotated loop has zero trip count / is never entered.
 static constexpr uint32_t ZeroTripCountWeights[] = {1, 127};
 
@@ -414,6 +418,9 @@ static void updateBranchWeights(BranchInst &PreHeaderBI, BranchInst &LoopBI,
 /// If -loop-rotate-multi is enabled we can do multiple rotations in one go
 /// so to reach a suitable (non-deoptimizing) exit.
 bool LoopRotate::rotateLoop(Loop *L, bool SimplifiedLatch) {
+  if (DisableLoopRotation)
+    return false;
+
   // If the loop has only one block then there is not much to rotate.
   if (L->getBlocks().size() == 1)
     return false;
@@ -1013,6 +1020,9 @@ static bool shouldSpeculateInstrs(BasicBlock::iterator Begin,
 ///
 /// I don't believe this invalidates SCEV.
 bool LoopRotate::simplifyLoopLatch(Loop *L) {
+  if (DisableLoopRotation)
+    return false;
+
   BasicBlock *Latch = L->getLoopLatch();
   if (!Latch || Latch->hasAddressTaken())
     return false;
@@ -1083,6 +1093,8 @@ bool llvm::LoopRotation(Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI,
                         const SimplifyQuery &SQ, bool RotationOnly = true,
                         unsigned Threshold = unsigned(-1),
                         bool IsUtilMode = true, bool PrepareForLTO) {
+  if (DisableLoopRotation)
+    return false;
   LoopRotate LR(Threshold, LI, TTI, AC, DT, SE, MSSAU, SQ, RotationOnly,
                 IsUtilMode, PrepareForLTO);
   return LR.processLoop(L);
diff --git a/llvm/lib/Transforms/Utils/LoopSimplify.cpp b/llvm/lib/Transforms/Utils/LoopSimplify.cpp
index a764fef57491..36e2928320d4 100644
--- a/llvm/lib/Transforms/Utils/LoopSimplify.cpp
+++ b/llvm/lib/Transforms/Utils/LoopSimplify.cpp
@@ -75,6 +75,9 @@ using namespace llvm;
 
 STATISTIC(NumNested  , "Number of nested loops split out");
 
+static cl::opt<bool> DisableLoopSimplify("disable-pass-loop-simplify", cl::init(false),
+                                         cl::Hidden, cl::desc("Disable LoopSimplify pass"));
+
 // If the block isn't already, move the new block to right after some 'outside
 // block' block.  This prevents the preheader from being placed inside the loop
 // body, e.g. when the loop hasn't been rotated.
@@ -825,6 +828,8 @@ bool LoopSimplify::runOnFunction(Function &F) {
 
 PreservedAnalyses LoopSimplifyPass::run(Function &F,
                                         FunctionAnalysisManager &AM) {
+  //   if (DisableLoopSimplify)
+  //     return PreservedAnalyses::all();
   bool Changed = false;
   LoopInfo *LI = &AM.getResult<LoopAnalysis>(F);
   DominatorTree *DT = &AM.getResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/Utils/LoopUnroll.cpp b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
index a0406111ecbf..0fcffd739865 100644
--- a/llvm/lib/Transforms/Utils/LoopUnroll.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
@@ -87,6 +87,8 @@ STATISTIC(NumUnrolled, "Number of loops unrolled (completely or otherwise)");
 STATISTIC(NumUnrolledNotLatch, "Number of loops unrolled without a conditional "
                                "latch (completely or otherwise)");
 
+extern cl::opt<bool> DisableLoopUnroll;
+
 static cl::opt<bool>
 UnrollRuntimeEpilog("unroll-runtime-epilog", cl::init(false), cl::Hidden,
                     cl::desc("Allow runtime unrolled loops to be unrolled "
@@ -461,6 +463,8 @@ llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,
                  ScalarEvolution *SE, DominatorTree *DT, AssumptionCache *AC,
                  const TargetTransformInfo *TTI, OptimizationRemarkEmitter *ORE,
                  bool PreserveLCSSA, Loop **RemainderLoop, AAResults *AA) {
+  if (DisableLoopUnroll)
+    return LoopUnrollResult::Unmodified;
   assert(DT && "DomTree is required");
 
   if (!L->getLoopPreheader()) {
diff --git a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
index c7b88d3c48a6..108fcd028d95 100644
--- a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
@@ -62,6 +62,11 @@ using namespace llvm;
 STATISTIC(NumUnrolledAndJammed, "Number of loops unroll and jammed");
 STATISTIC(NumCompletelyUnrolledAndJammed, "Number of loops unroll and jammed");
 
+cl::opt<bool>
+    DisableLoopUnrollAndJam("disable-pass-loop-unroll-and-jam", cl::init(false),
+                            cl::Hidden,
+                            cl::desc("Disable LoopUnrollAndJam pass"));
+
 typedef SmallPtrSet<BasicBlock *, 4> BasicBlockSet;
 
 // Partition blocks in an outer/inner loop pair into blocks before and after
@@ -218,6 +223,8 @@ llvm::UnrollAndJamLoop(Loop *L, unsigned Count, unsigned TripCount,
                        LoopInfo *LI, ScalarEvolution *SE, DominatorTree *DT,
                        AssumptionCache *AC, const TargetTransformInfo *TTI,
                        OptimizationRemarkEmitter *ORE, Loop **EpilogueLoop) {
+  if (DisableLoopUnrollAndJam)
+    return LoopUnrollResult::Unmodified;
 
   // When we enter here we should have already checked that it is safe
   BasicBlock *Header = L->getHeader();
diff --git a/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp b/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
index 56aa96e550d9..ccc6100189a6 100644
--- a/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
@@ -48,6 +48,7 @@ using namespace llvm;
 
 STATISTIC(NumRuntimeUnrolled,
           "Number of loops unrolled with run-time trip counts");
+extern cl::opt<bool> DisableLoopUnroll;
 static cl::opt<bool> UnrollRuntimeMultiExit(
     "unroll-runtime-multi-exit", cl::init(false), cl::Hidden,
     cl::desc("Allow runtime unrolling for loops with multiple exits, when "
@@ -584,6 +585,8 @@ bool llvm::UnrollRuntimeLoopRemainder(
     bool UseEpilogRemainder, bool UnrollRemainder, bool ForgetAllSCEV,
     LoopInfo *LI, ScalarEvolution *SE, DominatorTree *DT, AssumptionCache *AC,
     const TargetTransformInfo *TTI, bool PreserveLCSSA, Loop **ResultLoop) {
+  if (DisableLoopUnroll)
+    return false;
   LLVM_DEBUG(dbgs() << "Trying runtime unrolling on Loop: \n");
   LLVM_DEBUG(L->dump());
   LLVM_DEBUG(UseEpilogRemainder ? dbgs() << "Using epilog remainder.\n"
diff --git a/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp b/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
index 55f9400d93d7..b394fda0ab10 100644
--- a/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
+++ b/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
@@ -23,6 +23,7 @@
 #include "llvm/IR/Module.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/ModuleUtils.h"
 #include <map>
@@ -31,6 +32,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "lower-global-dtors"
 
+static cl::opt<bool> DisableLowerGlobalDtors("disable-pass-lower-global-dtors", cl::init(false), cl::Hidden, cl::desc("Disable LowerGlobalDtors pass"));
+
 namespace {
 class LowerGlobalDtorsLegacyPass final : public ModulePass {
   StringRef getPassName() const override {
@@ -61,10 +64,16 @@ ModulePass *llvm::createLowerGlobalDtorsLegacyPass() {
 }
 
 static bool runImpl(Module &M);
-bool LowerGlobalDtorsLegacyPass::runOnModule(Module &M) { return runImpl(M); }
+bool LowerGlobalDtorsLegacyPass::runOnModule(Module &M) {
+  if (DisableLowerGlobalDtors)
+    return false;
+  return runImpl(M);
+}
 
 PreservedAnalyses LowerGlobalDtorsPass::run(Module &M,
                                             ModuleAnalysisManager &AM) {
+  if (DisableLowerGlobalDtors)
+    return PreservedAnalyses::all();
   bool Changed = runImpl(M);
   if (!Changed)
     return PreservedAnalyses::all();
@@ -75,6 +84,8 @@ PreservedAnalyses LowerGlobalDtorsPass::run(Module &M,
 }
 
 static bool runImpl(Module &M) {
+  if (DisableLowerGlobalDtors)
+    return false;
   GlobalVariable *GV = M.getGlobalVariable("llvm.global_dtors");
   if (!GV || !GV->hasInitializer())
     return false;
diff --git a/llvm/lib/Transforms/Utils/LowerInvoke.cpp b/llvm/lib/Transforms/Utils/LowerInvoke.cpp
index ff2ab3c6dce9..d015e72127a9 100644
--- a/llvm/lib/Transforms/Utils/LowerInvoke.cpp
+++ b/llvm/lib/Transforms/Utils/LowerInvoke.cpp
@@ -19,6 +19,7 @@
 #include "llvm/IR/Instructions.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils.h"
 using namespace llvm;
 
@@ -26,6 +27,8 @@ using namespace llvm;
 
 STATISTIC(NumInvokes, "Number of invokes replaced");
 
+static cl::opt<bool> DisableLowerInvoke("disable-pass-lower-invoke", cl::init(false), cl::Hidden, cl::desc("Disable LowerInvoke pass"));
+
 namespace {
   class LowerInvokeLegacyPass : public FunctionPass {
   public:
@@ -43,6 +46,9 @@ INITIALIZE_PASS(LowerInvokeLegacyPass, "lowerinvoke",
                 false, false)
 
 static bool runImpl(Function &F) {
+  if (DisableLowerInvoke)
+    return false;
+
   bool Changed = false;
   for (BasicBlock &BB : F)
     if (InvokeInst *II = dyn_cast<InvokeInst>(BB.getTerminator())) {
@@ -75,6 +81,8 @@ static bool runImpl(Function &F) {
 }
 
 bool LowerInvokeLegacyPass::runOnFunction(Function &F) {
+  if (DisableLowerInvoke)
+    return false;
   return runImpl(F);
 }
 
@@ -86,6 +94,8 @@ FunctionPass *createLowerInvokePass() { return new LowerInvokeLegacyPass(); }
 
 PreservedAnalyses LowerInvokePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisableLowerInvoke)
+    return PreservedAnalyses::all();
   bool Changed = runImpl(F);
   if (!Changed)
     return PreservedAnalyses::all();
diff --git a/llvm/lib/Transforms/Utils/LowerSwitch.cpp b/llvm/lib/Transforms/Utils/LowerSwitch.cpp
index b5c4e93be574..9249e36e5c6f 100644
--- a/llvm/lib/Transforms/Utils/LowerSwitch.cpp
+++ b/llvm/lib/Transforms/Utils/LowerSwitch.cpp
@@ -32,6 +32,7 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/KnownBits.h"
@@ -48,6 +49,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "lower-switch"
 
+static cl::opt<bool> DisableLowerSwitch("disable-pass-lower-switch", cl::init(false), cl::Hidden, cl::desc("Disable LowerSwitch pass"));
+
 namespace {
 
 struct IntRange {
@@ -535,6 +538,9 @@ void ProcessSwitchInst(SwitchInst *SI,
 }
 
 bool LowerSwitch(Function &F, LazyValueInfo *LVI, AssumptionCache *AC) {
+  if (DisableLowerSwitch)
+    return false;
+
   bool Changed = false;
   SmallPtrSet<BasicBlock *, 8> DeleteList;
 
@@ -596,6 +602,8 @@ FunctionPass *llvm::createLowerSwitchPass() {
 }
 
 bool LowerSwitchLegacyPass::runOnFunction(Function &F) {
+  if (DisableLowerSwitch)
+    return false;
   LazyValueInfo *LVI = &getAnalysis<LazyValueInfoWrapperPass>().getLVI();
   auto *ACT = getAnalysisIfAvailable<AssumptionCacheTracker>();
   AssumptionCache *AC = ACT ? &ACT->getAssumptionCache(F) : nullptr;
@@ -604,6 +612,8 @@ bool LowerSwitchLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses LowerSwitchPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisableLowerSwitch)
+    return PreservedAnalyses::all();
   LazyValueInfo *LVI = &AM.getResult<LazyValueAnalysis>(F);
   AssumptionCache *AC = AM.getCachedResult<AssumptionAnalysis>(F);
   return LowerSwitch(F, LVI, AC) ? PreservedAnalyses::none()
diff --git a/llvm/lib/Transforms/Utils/Mem2Reg.cpp b/llvm/lib/Transforms/Utils/Mem2Reg.cpp
index 5ad7aeb463ec..24bfc47ba7cf 100644
--- a/llvm/lib/Transforms/Utils/Mem2Reg.cpp
+++ b/llvm/lib/Transforms/Utils/Mem2Reg.cpp
@@ -22,6 +22,7 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/PromoteMemToReg.h"
 #include <vector>
@@ -32,8 +33,12 @@ using namespace llvm;
 
 STATISTIC(NumPromoted, "Number of alloca's promoted");
 
+static cl::opt<bool> DisableMem2Reg("disable-pass-mem2reg", cl::init(false), cl::Hidden, cl::desc("Disable Mem2Reg pass"));
+
 static bool promoteMemoryToRegister(Function &F, DominatorTree &DT,
                                     AssumptionCache &AC) {
+  if (DisableMem2Reg)
+    return false;
   std::vector<AllocaInst *> Allocas;
   BasicBlock &BB = F.getEntryBlock(); // Get the entry node for the function
   bool Changed = false;
@@ -59,6 +64,8 @@ static bool promoteMemoryToRegister(Function &F, DominatorTree &DT,
 }
 
 PreservedAnalyses PromotePass::run(Function &F, FunctionAnalysisManager &AM) {
+  if (DisableMem2Reg)
+    return PreservedAnalyses::all();
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   if (!promoteMemoryToRegister(F, DT, AC))
@@ -82,6 +89,8 @@ struct PromoteLegacyPass : public FunctionPass {
   // runOnFunction - To run this pass, first we calculate the alloca
   // instructions that are safe for promotion, then we promote each one.
   bool runOnFunction(Function &F) override {
+    if (DisableMem2Reg)
+      return false;
     if (skipFunction(F))
       return false;
 
diff --git a/llvm/lib/Transforms/Utils/UnifyFunctionExitNodes.cpp b/llvm/lib/Transforms/Utils/UnifyFunctionExitNodes.cpp
index d5468909dd4e..d4d39eea8daf 100644
--- a/llvm/lib/Transforms/Utils/UnifyFunctionExitNodes.cpp
+++ b/llvm/lib/Transforms/Utils/UnifyFunctionExitNodes.cpp
@@ -16,11 +16,15 @@
 #include "llvm/IR/Function.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/Type.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Utils.h"
 using namespace llvm;
 
 namespace {
 
+static cl::opt<bool> DisableMergeReturn("disable-pass-mergereturn", cl::init(false),
+                                        cl::Hidden, cl::desc("Disable mergereturn pass"));
+
 bool unifyUnreachableBlocks(Function &F) {
   std::vector<BasicBlock *> UnreachableBlocks;
 
@@ -88,6 +92,8 @@ bool unifyReturnBlocks(Function &F) {
 
 PreservedAnalyses UnifyFunctionExitNodesPass::run(Function &F,
                                                   FunctionAnalysisManager &AM) {
+  if (DisableMergeReturn)
+    return PreservedAnalyses::all();
   bool Changed = false;
   Changed |= unifyUnreachableBlocks(F);
   Changed |= unifyReturnBlocks(F);
